"use strict";
const tslib_1 = require("tslib");
const util_1 = require("../../../net-stubbing/lib/server/util");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const bluebird_1 = tslib_1.__importDefault(require("bluebird"));
const fixture_1 = tslib_1.__importDefault(require("../fixture"));
const fixturesRe = /^(fx:|fixture:)/;
module.exports = {
    handle(req, res, config, next) {
        const get = function (val, def) {
            return decodeURI(req.get(val) || def);
        };
        const delay = ~~get('x-cypress-delay');
        const status = get('x-cypress-status', 200);
        let headers = get('x-cypress-headers', null);
        const response = get('x-cypress-response', '');
        const respond = () => {
            // figure out the stream interface and pipe these
            // chunks to the response
            return this.getResponse(response, config)
                .then((resp) => {
                let { data, encoding } = resp;
                // grab content-type from x-cypress-headers if present
                headers = this.parseHeaders(headers, data);
                // enable us to respond with other encodings
                // like binary
                if (encoding == null) {
                    encoding = 'utf8';
                }
                // TODO: if data is binary then set
                // content-type to binary/octet-stream
                if (lodash_1.default.isObject(data)) {
                    data = JSON.stringify(data);
                }
                // when data is null, JSON.stringify returns null.
                // handle that case.
                if (data === null) {
                    data = '';
                }
                if (lodash_1.default.isNumber(data) || lodash_1.default.isBoolean(data)) {
                    data = String(data);
                }
                const chunk = Buffer.from(data, encoding);
                headers['content-length'] = chunk.length;
                return res
                    .set(headers)
                    .status(status)
                    .end(chunk);
            }).catch((err) => {
                return res
                    .status(400)
                    .send({ __error: err.stack });
            });
        };
        if (delay > 0) {
            return bluebird_1.default.delay(delay).then(respond);
        }
        return respond();
    },
    _get(resp, config) {
        const options = {};
        const file = resp.replace(fixturesRe, '');
        const [filePath, encoding] = file.split(',');
        if (encoding) {
            options.encoding = encoding;
        }
        return fixture_1.default.get(config.fixturesFolder, filePath, options)
            .then((bytes) => {
            return {
                data: bytes,
                encoding,
            };
        });
    },
    getResponse(resp, config) {
        if (fixturesRe.test(resp)) {
            return this._get(resp, config);
        }
        return bluebird_1.default.resolve({ data: resp });
    },
    parseHeaders(headers, response) {
        try {
            headers = JSON.parse(headers);
        }
        catch (error) { } // eslint-disable-line no-empty
        if (headers == null) {
            headers = {};
        }
        if (headers['content-type'] == null) {
            headers['content-type'] = (0, util_1.parseContentType)(response);
        }
        return headers;
    },
};
