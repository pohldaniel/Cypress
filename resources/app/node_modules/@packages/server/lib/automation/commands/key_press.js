"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bidiKeyPress = exports.BIDI_VALUE = exports.cdpKeyPress = exports.CDP_KEYCODE = exports.isSupportedKey = exports.InvalidKeyError = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const lodash_1 = require("lodash");
const debug = (0, debug_1.default)('cypress:server:automation:command:keypress');
const invalidKeyErrorKind = 'InvalidKeyError';
class InvalidKeyError extends Error {
    constructor(key) {
        super(`${key} is not supported by 'cy.press()'.`);
        this.kind = invalidKeyErrorKind;
    }
    static isInvalidKeyError(e) {
        return e.kind === invalidKeyErrorKind;
    }
}
exports.InvalidKeyError = InvalidKeyError;
function isSupportedKey(key) {
    return exports.CDP_KEYCODE[key] && exports.BIDI_VALUE[key];
}
exports.isSupportedKey = isSupportedKey;
exports.CDP_KEYCODE = {
    'Tab': 'U+000009',
};
async function evaluateInFrameContext(expression, send, contexts, frame) {
    var _a;
    for (const [contextId, context] of contexts.entries()) {
        if (((_a = context.auxData) === null || _a === void 0 ? void 0 : _a.frameId) === frame.id) {
            try {
                return await send('Runtime.evaluate', {
                    expression,
                    contextId,
                });
            }
            catch (e) {
                if ((0, lodash_1.isError)(e) && e.message.includes('Cannot find context with specified id')) {
                    debug('found invalid context %d, removing', contextId);
                    contexts.delete(contextId);
                }
            }
        }
    }
    throw new Error('Unable to find valid context for frame');
}
async function cdpKeyPress({ key }, send, contexts, frameTree) {
    var _a;
    debug('cdp keypress', { key });
    if (!exports.CDP_KEYCODE[key]) {
        throw new InvalidKeyError(key);
    }
    const keyIdentifier = exports.CDP_KEYCODE[key];
    const autFrame = (_a = frameTree.childFrames) === null || _a === void 0 ? void 0 : _a.find(({ frame }) => {
        var _a;
        return (_a = frame.name) === null || _a === void 0 ? void 0 : _a.includes('Your project');
    });
    if (!autFrame) {
        throw new Error('Could not find AUT frame');
    }
    const topActiveElement = await evaluateInFrameContext('document.activeElement', send, contexts, frameTree.frame);
    const autFrameIsActive = topActiveElement.result.description && autFrame.frame.name && topActiveElement.result.description.includes(autFrame.frame.name);
    if (!autFrameIsActive) {
        await evaluateInFrameContext('window.focus()', send, contexts, autFrame.frame);
    }
    try {
        await send('Input.dispatchKeyEvent', {
            type: 'keyDown',
            key,
            code: key,
            keyIdentifier,
        });
        await send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            key,
            code: key,
            keyIdentifier,
        });
    }
    catch (e) {
        debug(e);
        throw e;
    }
}
exports.cdpKeyPress = cdpKeyPress;
exports.BIDI_VALUE = {
    'Tab': '\uE004',
};
async function getActiveWindow(client) {
    try {
        return await client.getWindowHandle();
    }
    catch (e) {
        return undefined;
    }
}
async function bidiKeyPress({ key }, client, autContext, idSuffix) {
    const value = exports.BIDI_VALUE[key];
    if (!value) {
        throw new InvalidKeyError(key);
    }
    const activeWindow = await getActiveWindow(client);
    const { contexts: [{ context: topLevelContext }] } = await client.browsingContextGetTree({});
    // TODO: refactor for Cy15 https://github.com/cypress-io/cypress/issues/31480
    if (activeWindow !== topLevelContext) {
        debug('Primary window is not currently active; attempting to activate');
        try {
            await client.switchToWindow(topLevelContext);
        }
        catch (e) {
            debug('Error while attempting to activate main browser tab:', e);
            const err = new Error(`Unable to activate main browser tab: ${(e === null || e === void 0 ? void 0 : e.message) || 'Unknown Error Occurred'}. DEBUG namespace cypress:server:automation:command:keypress for more information.`);
            throw err;
        }
    }
    try {
        const autFrameElement = await client.findElement('css selector', 'iframe.aut-iframe');
        const activeElement = await client.getActiveElement();
        if (!(0, lodash_1.isEqual)(autFrameElement, activeElement)) {
            debug('aut iframe is not currently focused; focusing aut iframe: ', autContext);
            await client.scriptEvaluate({
                expression: `window.focus()`,
                target: { context: autContext },
                awaitPromise: false,
            });
        }
    }
    catch (e) {
        debug('Error occurred during aut frame focus detection:', e);
        const err = new Error(`Unable to focus the AUT iframe: ${(e === null || e === void 0 ? void 0 : e.message) || 'Unknown Error Occurred'}. DEBUG namespace cypress:server:automation:command:keypress for more information.`);
        throw err;
    }
    try {
        await client.inputPerformActions({
            context: autContext,
            actions: [{
                    type: 'key',
                    id: `${autContext}-${key}-${idSuffix || Date.now()}`,
                    actions: [
                        { type: 'keyDown', value },
                        { type: 'keyUp', value },
                    ],
                }],
        });
    }
    catch (e) {
        debug(e);
        const err = new Error(`Unable to perform key press command for '${key}' key: ${(e === null || e === void 0 ? void 0 : e.message) || 'Unknown Error Occurred'}. DEBUG namespace cypress:server:automation:command:keypress for more information.`);
        throw err;
    }
}
exports.bidiKeyPress = bidiKeyPress;
