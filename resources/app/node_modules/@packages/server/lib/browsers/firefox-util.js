"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const cdp_automation_1 = require("./cdp_automation");
const bidi_automation_1 = require("./bidi_automation");
const browser_cri_client_1 = require("./browser-cri-client");
const debug = (0, debug_1.default)('cypress:server:browsers:firefox-util');
let webdriverClient;
async function connectToNewSpecBiDi(options, automation, browserBiDiClient) {
    // when connecting to a new spec, we need to re register the existing bidi client to the automation client
    // as the automation client resets its middleware between specs in run mode
    debug('firefox: reconnecting to blank tab');
    const { contexts } = await webdriverClient.browsingContextGetTree({});
    browserBiDiClient.setTopLevelContextId(contexts[0].context);
    await options.onInitializeNewBrowserTab();
    debug(`firefox: navigating to ${options.url}`);
    await webdriverClient.browsingContextNavigate({
        context: contexts[0].context,
        url: options.url,
    });
}
async function connectToNewSpecCDP(options, automation, browserCriClient) {
    var _a, _b;
    debug('firefox: reconnecting to blank tab');
    // Firefox keeps a blank tab open in versions of Firefox 123 and lower when the last tab is closed.
    // For versions 124 and above, a new tab is not created, so @packages/extension creates one for us.
    // Since the tab is always available on our behalf,
    // we can connect to it here and navigate it to about:blank to set it up for CDP connection
    const handles = await webdriverClient.getWindowHandles();
    await webdriverClient.switchToWindow(handles[0]);
    await webdriverClient.navigateTo('about:blank');
    debug('firefox: reconnecting CDP');
    if (browserCriClient) {
        await ((_a = browserCriClient.currentlyAttachedTarget) === null || _a === void 0 ? void 0 : _a.close().catch(() => { }));
        // Strictly speaking this shouldn't ever happen in firefox, but to future proof adding it in case.
        await ((_b = browserCriClient.currentlyAttachedProtocolTarget) === null || _b === void 0 ? void 0 : _b.close().catch(() => { }));
        const pageCriClient = await browserCriClient.attachToTargetUrl('about:blank');
        await cdp_automation_1.CdpAutomation.create(pageCriClient.send, pageCriClient.on, pageCriClient.off, browserCriClient.resetBrowserTargets, automation);
    }
    await options.onInitializeNewBrowserTab();
    debug(`firefox: navigating to ${options.url}`);
    await webdriverClient.navigateTo(options.url);
}
async function setupBiDi(webdriverClient, automation) {
    // webdriver needs to subscribe to the correct BiDi events or else the events we are expecting to stream in will not be sent
    await webdriverClient.sessionSubscribe({ events: bidi_automation_1.BidiAutomation.BIDI_EVENTS });
    const biDiClient = bidi_automation_1.BidiAutomation.create(webdriverClient, automation);
    return biDiClient;
}
async function setupCDP(remotePort, automation, onError) {
    const browserCriClient = await browser_cri_client_1.BrowserCriClient.create({ hosts: ['127.0.0.1', '::1'], port: remotePort, browserName: 'Firefox', onAsynchronousError: onError, onServiceWorkerClientEvent: automation.onServiceWorkerClientEvent });
    const pageCriClient = await browserCriClient.attachToTargetUrl('about:blank');
    await cdp_automation_1.CdpAutomation.create(pageCriClient.send, pageCriClient.on, pageCriClient.off, browserCriClient.resetBrowserTargets, automation);
    return browserCriClient;
}
exports.default = {
    async setup({ automation, onError, url, remotePort, webdriverClient: wdInstance, useWebDriverBiDi, }) {
        // set the WebDriver classic instance instantiated from geckodriver
        webdriverClient = wdInstance;
        let client;
        if (useWebDriverBiDi) {
            client = await setupBiDi(webdriverClient, automation);
            // use the BiDi commands to visit the url as opposed to classic webdriver
            const { contexts } = await webdriverClient.browsingContextGetTree({});
            // at this point there should only be one context: the top level context.
            // we need to set this to bind our AUT intercepts correctly. Hopefully we can move this in the future on a more sure implementation
            client.setTopLevelContextId(contexts[0].context);
            automation.use(client.automationMiddleware);
            await webdriverClient.browsingContextNavigate({
                context: contexts[0].context,
                url,
            });
        }
        else {
            client = await setupCDP(remotePort, automation, onError);
            // uses webdriver classic to navigate
            await webdriverClient.navigateTo(url);
        }
        return client;
    },
    connectToNewSpecBiDi,
    connectToNewSpecCDP,
    setupBiDi,
    setupCDP,
};
