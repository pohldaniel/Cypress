"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDPConnection = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const events_1 = tslib_1.__importDefault(require("events"));
const chrome_remote_interface_1 = tslib_1.__importDefault(require("chrome-remote-interface"));
const debug_cdp_connection_1 = require("./debug-cdp-connection");
const cri_errors_1 = require("./cri-errors");
const async_retry_1 = require("../util/async_retry");
const errors = tslib_1.__importStar(require("../errors"));
const verboseDebugNs = 'cypress-verbose:server:browsers:cdp-connection';
/**
 * There are three error messages we can encounter which should not be re-thrown, but
 * should trigger a reconnection attempt if one is not in progress, and enqueue the
 * command that errored. This regex is used in client.send to check for:
 * - WebSocket connection closed
 * - WebSocket not open
 * - WebSocket already in CLOSING or CLOSED state
 */
const isWebsocketClosedErrorMessage = (message) => {
    return /^WebSocket (?:connection closed|is (?:not open|already in CLOSING or CLOSED state))/.test(message);
};
class CDPConnection {
    constructor(_options, connectionOptions) {
        this._options = _options;
        this._emitter = new events_1.default();
        this._terminated = false;
        this._gracefullyDisconnect = async () => {
            var _a, _b, _c;
            (_a = this._connection) === null || _a === void 0 ? void 0 : _a.off('event', this._broadcastEvent);
            (_b = this._connection) === null || _b === void 0 ? void 0 : _b.off('disconnect', this._reconnect);
            await ((_c = this._connection) === null || _c === void 0 ? void 0 : _c.close());
            this._connection = undefined;
        };
        this._reconnect = async () => {
            var _a;
            this.debug('Reconnection requested');
            if (this._terminated) {
                return;
            }
            if (this._reconnection) {
                return this._reconnection;
            }
            if (this._connection) {
                try {
                    await this._gracefullyDisconnect();
                }
                catch (e) {
                    this.debug('Error cleaning up existing CDP connection before creating a new connection: ', e);
                }
                finally {
                    this._connection = undefined;
                }
            }
            let attempt = 0;
            this._reconnection = (0, async_retry_1.asyncRetry)(async () => {
                attempt++;
                this.debug('Reconnection attempt %d for Target %s', attempt, this._options.target);
                if (this._terminated) {
                    this.debug('Not reconnecting, connection to %s has been terminated', this._options.target);
                    throw new cri_errors_1.CDPTerminatedError(`Cannot reconnect to CDP. Client target ${this._options.target} has been terminated.`);
                }
                this._emitter.emit('cdp-connection-reconnect-attempt', attempt);
                await this.connect();
            }, {
                maxAttempts: 20,
                retryDelay: () => {
                    return 100;
                },
                shouldRetry(err) {
                    return !(err && err instanceof Error && cri_errors_1.CDPTerminatedError.isCDPTerminatedError(err));
                },
            })();
            try {
                await this._reconnection;
                this._emitter.emit('cdp-connection-reconnect');
            }
            catch (err) {
                this.debug('error(s) on reconnecting: ', err);
                const significantError = err.errors ? err.errors[err.errors.length - 1] : err;
                const retryHaltedDueToClosed = cri_errors_1.CDPTerminatedError.isCDPTerminatedError(err) ||
                    ((_a = err === null || err === void 0 ? void 0 : err.errors) === null || _a === void 0 ? void 0 : _a.find((predicate) => cri_errors_1.CDPTerminatedError.isCDPTerminatedError(predicate)));
                // if .disconnect() was called while trying to reconnect, there will be no active connection
                // so the .disconnect() method will not emit the connection closed event. However, we do
                // want to emit that once the reconnection attempts cease due to being closed.
                if (retryHaltedDueToClosed) {
                    this._emitter.emit('cdp-connection-closed');
                }
                else {
                    const cdpError = errors.get('CDP_COULD_NOT_RECONNECT', significantError);
                    cdpError.isFatalApiErr = true;
                    this._emitter.emit('cdp-connection-reconnect-error', cdpError);
                }
            }
            this._reconnection = undefined;
        };
        this._broadcastEvent = ({ method, params, sessionId }) => {
            this.verboseDebug('rebroadcasting event', method, params, sessionId);
            this._emitter.emit('event', { method, params, sessionId });
            this._emitter.emit(method, params, sessionId);
            this._emitter.emit(`${method}.${sessionId}`, params);
        };
        this._autoReconnect = connectionOptions.automaticallyReconnect;
        this.debug = (0, debug_1.default)(`cypress:server:browsers:cdp-connection:${_options.target}`);
        this.verboseDebug = (0, debug_1.default)(`${verboseDebugNs}:${_options.target}`);
    }
    get terminated() {
        return this._terminated;
    }
    get ws() {
        // this is reached into by browser-cri-client to detect close events - needs rethinking
        return this._connection._ws;
    }
    on(event, callback) {
        this.debug('attaching event listener to cdp connection', event);
        this._emitter.on(event, callback);
    }
    addConnectionEventListener(event, callback) {
        this.debug('adding connection event listener for ', event);
        this._emitter.on(event, callback);
    }
    off(event, callback) {
        this._emitter.off(event, callback);
    }
    removeConnectionEventListener(event, callback) {
        this._emitter.off(event, callback);
    }
    async connect() {
        if (this._terminated) {
            throw new cri_errors_1.CDPTerminatedError(`Cannot connect to CDP. Client target ${this._options.target} has been terminated.`);
        }
        if (this._connection) {
            throw new cri_errors_1.CDPAlreadyConnectedError(`Cannot connect to CDP. Client target ${this._options.target} is already connected. Did you disconnect first?`);
        }
        this._connection = await (0, chrome_remote_interface_1.default)(this._options);
        (0, debug_cdp_connection_1.debugCdpConnection)(this.verboseDebug.namespace, this._connection);
        this._connection.on('event', this._broadcastEvent);
        if (this._autoReconnect) {
            this._connection.on('disconnect', this._reconnect);
        }
    }
    async disconnect() {
        this.debug('disconnect of target %s requested.', this._options.target, { terminated: this._terminated, connection: !!this._connection, reconnection: !!this._reconnection });
        if (this._terminated && !this._connection) {
            return;
        }
        this._terminated = true;
        if (this._connection) {
            await this._gracefullyDisconnect();
            this._emitter.emit('cdp-connection-closed');
        }
    }
    async send(command, data, sessionId) {
        if (this.terminated) {
            throw new cri_errors_1.CDPDisconnectedError(`${command} will not run as the CRI connection to Target ${this._options.target} has been terminated.`);
        }
        if (!this._connection) {
            throw new cri_errors_1.CDPDisconnectedError(`${command} will not run as the CRI connection to Target ${this._options.target} has not been established.`);
        }
        try {
            return await this._connection.send(command, data, sessionId);
        }
        catch (e) {
            // Clients may wish to determine if the command should be enqueued
            // should enqueue logic live in this class tho??
            if (isWebsocketClosedErrorMessage(e.message)) {
                throw new cri_errors_1.CDPDisconnectedError(`${command} failed due to the websocket being disconnected.`, e);
            }
            throw e;
        }
    }
}
exports.CDPConnection = CDPConnection;
