"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BidiAutomation = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const automation_not_implemented_1 = require("../automation/automation_not_implemented");
const key_press_1 = require("../automation/commands/key_press");
const debug = (0, debug_1.default)('cypress:server:browsers:bidi_automation');
const debugVerbose = (0, debug_1.default)('cypress-verbose:server:browsers:bidi_automation');
// maps the network initiator to a ResourceType (which is initially based on CDP).
// This provides us with consistency of types in our request/response middleware, which is important for cy.intercept().
const normalizeResourceType = (type) => {
    switch (type) {
        case 'css':
            return 'stylesheet';
        case 'xmlhttprequest':
            return 'xhr';
        case 'img':
            return 'image';
        case 'iframe':
            return 'document';
        // for types we cannot determine, we can set to other.
        case 'audio':
        case 'beacon':
        case 'body':
        case 'early-hints':
        case 'embed':
        case 'frame':
        case 'input':
        case 'link':
        case 'object':
        case 'track':
        case 'video':
        case null:
            return 'other';
        default:
            return type;
    }
};
class BidiAutomation {
    constructor(webDriverClient, automation) {
        this.autContextId = undefined;
        // set in firefox-utils when creating the webdriver session initially and in the 'reset:browser:tabs:for:next:spec' automation hook for subsequent tests when the top level context is recreated
        this.topLevelContextId = undefined;
        this.interceptId = undefined;
        this.setTopLevelContextId = (contextId) => {
            debug(`setting top level context ID to: ${contextId}`);
            this.topLevelContextId = contextId;
        };
        this.onBrowsingContextCreated = async (params) => {
            debugVerbose('received browsingContext.contextCreated %o', params);
            // the AUT iframe is always the FIRST child created by the top level parent (second is the reporter, if it exists which isnt the case for headless/test replay)
            if (!this.autContextId && params.parent && this.topLevelContextId === params.parent) {
                debug(`new browsing context ${params.context} created within top-level parent context ${params.parent}.`);
                debug(`setting browsing context ${params.context} as the AUT context.`);
                this.autContextId = params.context;
                // in the case of top reloads for setting the url between specs, the AUT context gets destroyed but the top level context still exists.
                // in this case, we do NOT have to redefine the top level context intercept but instead update the autContextId to properly identify the
                // AUT in the request interceptor.
                if (!this.interceptId) {
                    debugVerbose(`no interceptor defined for top-level context ${params.parent}.`);
                    debugVerbose(`creating interceptor to determine if a request belongs to the AUT.`);
                    // BiDi can only intercept top level tab contexts (i.e., not iframes), so the intercept needs to be defined on the top level parent, which is the AUTs
                    // direct parent in ALL cases. This gets cleaned up in the 'reset:browser:tabs:for:next:spec' automation hook.
                    // error looks something like: Error: WebDriver Bidi command "network.addIntercept" failed with error: invalid argument - Context with id 123456789 is not a top-level browsing context
                    const { intercept } = await this.webDriverClient.networkAddIntercept({ phases: ['beforeRequestSent'], contexts: [params.parent] });
                    debugVerbose(`created network intercept ${intercept} for top-level browsing context ${params.parent}`);
                    // save a reference to the intercept ID to be cleaned up in the 'reset:browser:tabs:for:next:spec' automation hook.
                    this.interceptId = intercept;
                }
            }
        };
        this.onBrowsingContextDestroyed = async (params) => {
            debugVerbose('received browsingContext.contextDestroyed %o', params);
            // if the top level context gets destroyed, we need to clear the AUT context and destroy the interceptor as it is no longer applicable
            if (params.context === this.topLevelContextId) {
                debug(`top level browsing context ${params.context} destroyed`);
                // if the top level context is destroyed, we can imply that the AUT context is destroyed along with it
                this.autContextId = undefined;
                this.setTopLevelContextId(undefined);
                if (this.interceptId) {
                    // since we either have:
                    //   1. a new upper level browser context created above with shouldKeepTabOpen set to true.
                    //   2. all the previous contexts are destroyed.
                    // we should clean up our top level interceptor to prevent a memory leak as we no longer need it
                    await this.webDriverClient.networkRemoveIntercept({
                        intercept: this.interceptId,
                    });
                    debug(`destroyed network intercept ${this.interceptId}`);
                    this.interceptId = undefined;
                }
            }
            // if the AUT context is destroyed (possible that the top level context did not), clear the AUT context Id
            if (params.context === this.autContextId) {
                debug(`AUT browsing context ${params.context} destroyed within top-level parent context ${params.parent}.`);
                this.autContextId = undefined;
            }
        };
        this.onBeforeRequestSent = async (params) => {
            var _a, _b, _c, _d;
            debugVerbose('received network.beforeRequestSend %o', params);
            let url = params.request.url;
            const parsedHeaders = {};
            params.request.headers.forEach((header) => {
                parsedHeaders[header.name] = header.value.value;
            });
            const resourceType = normalizeResourceType(params.request.initiatorType);
            const urlWithoutHash = url.includes('#') ? url.substring(0, url.indexOf('#')) : url;
            const browserPreRequest = {
                requestId: params.request.request,
                method: params.request.method,
                // urls coming into the http middleware contain query params, but lack the hash. To get an accurate key to match on the prerequest, we need to remove the hash.
                url: urlWithoutHash,
                headers: parsedHeaders,
                resourceType,
                originalResourceType: params.request.initiatorType || params.request.destination,
                initiator: params.initiator,
                // Since we are NOT using CDP, we set the values to 0 to indicate that we do not have this information.
                // This is important when determining pre-request timeout and removal behavior
                cdpRequestWillBeSentTimestamp: 0,
                cdpRequestWillBeSentReceivedTimestamp: 0,
            };
            debugVerbose(`prerequest received for request ID ${params.request.request}: %o`, browserPreRequest);
            await ((_b = (_a = this.automation).onBrowserPreRequest) === null || _b === void 0 ? void 0 : _b.call(_a, browserPreRequest));
            // since all requests coming from the top level context are blocked, we need to continue them here
            // we only want to mutate requests coming from the AUT frame so we can add the X-Cypress-Is-AUT-Frame header
            // so the request-middleware can identify the request
            if (params.isBlocked) {
                params.request.headers.push({
                    name: 'X-Cypress-Is-WebDriver-BiDi',
                    value: {
                        type: 'string',
                        value: 'true',
                    },
                });
                if (params.context === this.autContextId && resourceType === 'document') {
                    debug(`AUT request detected, adding X-Cypress-Is-AUT-Frame for request ID: ${params.request.request}`);
                    params.request.headers.push({
                        name: 'X-Cypress-Is-AUT-Frame',
                        value: {
                            type: 'string',
                            value: 'true',
                        },
                    });
                }
                try {
                    debug(`continuing request ID: ${params.request.request}`);
                    await this.webDriverClient.networkContinueRequest({
                        request: params.request.request,
                        headers: params.request.headers,
                        cookies: params.request.cookies,
                    });
                }
                catch (err) {
                    debugVerbose(`error continuing request: %o`, err);
                    debugVerbose(`removing prerequest for request ID: ${params.request.request}`);
                    // if the continueRequest fails for any reason, we need to remove the prerequest from the automation client
                    (_d = (_c = this.automation).onRemoveBrowserPreRequest) === null || _d === void 0 ? void 0 : _d.call(_c, params.request.request);
                    // happens if you kill the Cypress app in the middle of request interception. This error can be ignored
                    if (!(err === null || err === void 0 ? void 0 : err.message.includes('no such request'))) {
                        throw err;
                    }
                }
            }
        };
        this.onResponseStarted = (params) => {
            var _a, _b;
            debugVerbose('received network.responseStarted %o', params);
            if (params.response.fromCache) {
                (_b = (_a = this.automation).onRemoveBrowserPreRequest) === null || _b === void 0 ? void 0 : _b.call(_a, params.request.request);
            }
        };
        this.onResponseComplete = (params) => {
            var _a, _b, _c, _d;
            debugVerbose('received network.responseComplete %o', params);
            if (params.response.fromCache) {
                (_b = (_a = this.automation).onRemoveBrowserPreRequest) === null || _b === void 0 ? void 0 : _b.call(_a, params.request.request);
                return;
            }
            const parsedHeaders = {};
            params.response.headers.forEach((header) => {
                parsedHeaders[header.name] = header.value.value;
            });
            const browserResponseReceived = {
                requestId: params.request.request,
                status: params.response.status,
                headers: parsedHeaders,
            };
            (_d = (_c = this.automation).onRequestEvent) === null || _d === void 0 ? void 0 : _d.call(_c, 'response:received', browserResponseReceived);
        };
        this.onFetchError = (params) => {
            var _a, _b;
            debugVerbose('received network.fetchError %o', params);
            (_b = (_a = this.automation).onRemoveBrowserPreRequest) === null || _b === void 0 ? void 0 : _b.call(_a, params.request.request);
        };
        this.automationMiddleware = {
            onRequest: async (message, data) => {
                debugVerbose('automation command \'%s\' requested with data: %O', message, data);
                debug('BiDi middleware handling msg `%s` for top context %s', message, this.topLevelContextId);
                switch (message) {
                    case 'key:press':
                        if (this.autContextId) {
                            await (0, key_press_1.bidiKeyPress)(data, this.webDriverClient, this.autContextId, this.topLevelContextId);
                        }
                        else {
                            throw new Error('Cannot emit key press: no AUT context initialized');
                        }
                        return;
                    default:
                        debug('BiDi automation not implemented for message: %s', message);
                        throw new automation_not_implemented_1.AutomationNotImplemented(message, 'BiDiAutomation');
                }
            },
        };
        debug('initializing bidi automation');
        this.automation = automation;
        this.webDriverClient = webDriverClient;
        // bind Bidi Events to update the standard automation client
        // Error here is expected until webdriver adds initiatorType and destination to the request object
        // @ts-expect-error
        this.webDriverClient.on('network.beforeRequestSent', this.onBeforeRequestSent);
        this.webDriverClient.on('network.responseStarted', this.onResponseStarted);
        this.webDriverClient.on('network.responseCompleted', this.onResponseComplete);
        this.webDriverClient.on('network.fetchError', this.onFetchError);
        this.webDriverClient.on('browsingContext.contextCreated', this.onBrowsingContextCreated);
        this.webDriverClient.on('browsingContext.contextDestroyed', this.onBrowsingContextDestroyed);
    }
    close() {
        this.webDriverClient.off('network.beforeRequestSent', this.onBeforeRequestSent);
        this.webDriverClient.off('network.responseStarted', this.onResponseStarted);
        this.webDriverClient.off('network.responseCompleted', this.onResponseComplete);
        this.webDriverClient.off('network.fetchError', this.onFetchError);
        this.webDriverClient.off('browsingContext.contextCreated', this.onBrowsingContextCreated);
        this.webDriverClient.off('browsingContext.contextDestroyed', this.onBrowsingContextDestroyed);
    }
    static create(webdriverClient, automation) {
        return new BidiAutomation(webdriverClient, automation);
    }
}
exports.BidiAutomation = BidiAutomation;
// events needed to subscribe to in order for our BiDi automation to work properly
BidiAutomation.BIDI_EVENTS = [
    'network.beforeRequestSent',
    'network.responseStarted',
    'network.responseCompleted',
    'network.fetchError',
    'browsingContext.contextCreated',
    'browsingContext.contextDestroyed',
];
