"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDPAlreadyConnectedError = exports.CDPTerminatedError = exports.CDPDisconnectedError = exports.CDPCrashedError = void 0;
const Kinds = Object.freeze({
    CDP_CRASHED: 'cdp_crashed',
    CDP_DISCONNECTED: 'cdp_disconnected',
    CDP_TERMINATED: 'cdp_terminated',
    CDP_ALREADY_CONNECTED: 'cdp_already_connected',
});
class CDPCrashedError extends Error {
    constructor() {
        super(...arguments);
        this.kind = Kinds.CDP_CRASHED;
    }
    static isCDPCrashedError(error) {
        return error.kind === Kinds.CDP_CRASHED;
    }
}
exports.CDPCrashedError = CDPCrashedError;
class CDPDisconnectedError extends Error {
    constructor(message, originalError) {
        super(message);
        this.originalError = originalError;
        this.kind = Kinds.CDP_DISCONNECTED;
    }
    static isCDPDisconnectedError(error) {
        return error.kind === Kinds.CDP_DISCONNECTED;
    }
}
exports.CDPDisconnectedError = CDPDisconnectedError;
class CDPTerminatedError extends Error {
    constructor(message, originalError) {
        super(message);
        this.originalError = originalError;
        this.kind = Kinds.CDP_TERMINATED;
    }
    static isCDPTerminatedError(error) {
        return error.kind === Kinds.CDP_TERMINATED;
    }
}
exports.CDPTerminatedError = CDPTerminatedError;
class CDPAlreadyConnectedError extends Error {
    constructor(message, originalError) {
        super(message);
        this.originalError = originalError;
        this.kind = Kinds.CDP_ALREADY_CONNECTED;
    }
    static isCDPAlreadyConnectedError(error) {
        return error.kind === Kinds.CDP_ALREADY_CONNECTED;
    }
}
exports.CDPAlreadyConnectedError = CDPAlreadyConnectedError;
