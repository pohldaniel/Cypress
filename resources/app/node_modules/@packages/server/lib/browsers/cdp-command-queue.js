"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDPCommandQueue = void 0;
const tslib_1 = require("tslib");
const p_defer_1 = tslib_1.__importDefault(require("p-defer"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const debug = (0, debug_1.default)('cypress:server:browsers:cdp-command-queue');
const debugVerbose = (0, debug_1.default)('cypress:server:browsers:cd-command-queue');
class CDPCommandQueue {
    constructor() {
        this.queue = [];
    }
    get entries() {
        return [...this.queue];
    }
    add(command, params, sessionId) {
        debug('enqueing command %s', command);
        debugVerbose('enqueing command %s with params %o', command, params);
        const deferred = (0, p_defer_1.default)();
        const commandPackage = {
            command,
            params,
            deferred,
            sessionId,
        };
        this.queue.push(commandPackage);
        debug('Command enqueued; new length: %d', this.queue.length);
        debugVerbose('Queue Contents: %O', this.queue);
        return deferred.promise;
    }
    clear() {
        debug('clearing command queue');
        this.queue = [];
    }
    extract(search) {
        // this should find, remove, and return if found a given command
        const index = this.queue.findIndex((enqueued) => {
            for (let k of Object.keys(search)) {
                if (search[k] !== enqueued[k]) {
                    return false;
                }
            }
            return true;
        });
        debug('extracting %o from commands at index %d', search, index);
        if (index === -1) {
            return undefined;
        }
        const [extracted] = this.queue.splice(index, 1);
        return extracted;
    }
    shift() {
        return this.queue.shift();
    }
    unshift(value) {
        return this.queue.unshift(value);
    }
}
exports.CDPCommandQueue = CDPCommandQueue;
