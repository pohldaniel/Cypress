"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamActivityMonitor = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const stream_1 = require("stream");
const stream_stalled_error_1 = require("./stream_stalled_error");
const debug = (0, debug_1.default)('cypress:server:cloud:stream-activity-monitor');
const debugVerbose = (0, debug_1.default)('cypress-verbose:server:cloud:stream-activity-monitor');
/**
 * `StreamActivityMonitor` encapsulates state with regard to monitoring a stream for flow
 * failure states. Given a maxActivityDwellTime, this class can `monitor` a Node Readable
 * stream and signal if the sink (e.g., a `fetch`) should be aborted via an AbortController
 * that can be retried via `getController`. It does this by creating an identity Transform
 * stream and piping the source stream through it. The transform stream receives each chunk
 * that the source emits, and orchestrates some timeouts to determine if the stream has stalled.
 *
 * Example usage:
 *
 * const MAX_ACTIVITY_DWELL_TIME = 5000
 * const stallDetection = new StreamActivityMonitor(MAX_ACTIVITY_DWELL_TIME)
 * try {
 *   const source = fs.createReadStream('/some/source/file')
 *   await fetch('/destination/url', {
 *     method: 'PUT',
 *     body: stallDetection.monitor(source)
 *     signal: stallDetection.getController().signal
 *   })
 * } catch (e) {
 *   if (stallDetection.getController().signal.reason) {
 *     // the `fetch` was aborted by the signal that `stallDetection` controlled
 *   }
 * }
 *
 */
const DEFAULT_FS_READSTREAM_CHUNK_SIZE = 64 * 1024; // Kilobytes
class StreamActivityMonitor {
    constructor(maxActivityDwellTime) {
        this.maxActivityDwellTime = maxActivityDwellTime;
        this.controller = new AbortController();
    }
    getController() {
        return this.controller;
    }
    monitor(stream) {
        debug('monitoring stream');
        if (this.streamMonitor || this.activityTimeout) {
            this.reset();
        }
        this.streamMonitor = new stream_1.Transform({
            transform: (chunk, _, callback) => {
                debugVerbose('Received chunk from File ReadableStream; Enqueing to network: ', chunk.length);
                this.markActivityInterval();
                callback(null, chunk);
            },
        });
        return stream.pipe(this.streamMonitor);
    }
    reset() {
        debug('Resetting Stream Activity Monitor');
        clearTimeout(this.activityTimeout);
        this.streamMonitor = undefined;
        this.activityTimeout = undefined;
        this.controller = new AbortController();
    }
    markActivityInterval() {
        debug('marking activity interval');
        clearTimeout(this.activityTimeout);
        this.activityTimeout = setTimeout(() => {
            var _a;
            (_a = this.controller) === null || _a === void 0 ? void 0 : _a.abort(new stream_stalled_error_1.StreamStalledError(this.maxActivityDwellTime, DEFAULT_FS_READSTREAM_CHUNK_SIZE));
        }, this.maxActivityDwellTime);
    }
}
exports.StreamActivityMonitor = StreamActivityMonitor;
