"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadArtifacts = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const types_1 = require("../../../../types");
const api_1 = tslib_1.__importDefault(require("../api"));
const print_run_1 = require("../../util/print-run");
const errors = tslib_1.__importStar(require("../../errors"));
const exception_1 = tslib_1.__importDefault(require("../exception"));
const artifact_1 = require("./artifact");
const screenshot_artifact_1 = require("./screenshot_artifact");
const video_artifact_1 = require("./video_artifact");
const protocol_artifact_1 = require("./protocol_artifact");
const http_error_1 = require("../network/http_error");
const print_protocol_upload_error_1 = require("./print_protocol_upload_error");
const debug = (0, debug_1.default)('cypress:server:cloud:artifacts');
const removeWhitespaceAndTrim = (str) => {
    return str.split(/\n/)
        .map((line) => {
        return line.trim();
    })
        .join('');
};
const toUploadReportPayload = (acc, { key, ...report }) => {
    const reportWithoutOriginalError = lodash_1.default.omit(report, 'originalError');
    if (key === artifact_1.ArtifactKinds.PROTOCOL) {
        let { error, errorStack, allErrors } = reportWithoutOriginalError;
        if (allErrors) {
            const messages = allErrors.map((error) => {
                return (http_error_1.HttpError.isHttpError(error) && error.responseBody) ?
                    `${error.message}: ${removeWhitespaceAndTrim(error.responseBody)}` :
                    error.message;
            });
            error = `Failed to upload Test Replay after ${allErrors.length} attempts. Errors: ${messages.join(', ')}`;
            errorStack = allErrors.map((error) => error.stack).join('');
        }
        else if (error) {
            error = `Failed to upload Test Replay: ${error}`;
        }
        debug('protocol report %O', reportWithoutOriginalError);
        return {
            ...acc,
            protocol: {
                ...reportWithoutOriginalError,
                error,
                errorStack,
            },
        };
    }
    return {
        ...acc,
        [key]: (key === 'screenshots') ? [...acc.screenshots, reportWithoutOriginalError] : reportWithoutOriginalError,
    };
};
const extractArtifactsFromOptions = async ({ video, videoUploadUrl, screenshots, screenshotUploadUrls, captureUploadUrl, protocolCaptureMeta, protocolManager, }) => {
    const artifacts = [];
    if (videoUploadUrl && video) {
        try {
            artifacts.push(await (0, video_artifact_1.createVideoArtifact)(video, videoUploadUrl));
        }
        catch (e) {
            debug('Error creating video artifact: %O', e);
        }
    }
    debug('screenshot metadata: %O', { screenshotUploadUrls, screenshots });
    debug('found screenshot filenames: %o', screenshots);
    if ((screenshots === null || screenshots === void 0 ? void 0 : screenshots.length) && (screenshotUploadUrls === null || screenshotUploadUrls === void 0 ? void 0 : screenshotUploadUrls.length)) {
        const screenshotArtifacts = await (0, screenshot_artifact_1.createScreenshotArtifactBatch)(screenshotUploadUrls, screenshots);
        screenshotArtifacts.forEach((screenshot) => {
            artifacts.push(screenshot);
        });
    }
    try {
        const protocolFilePath = protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getArchivePath();
        const shouldAddProtocolArtifact = protocolManager && protocolFilePath && captureUploadUrl && !protocolManager.hasFatalError();
        debug('should add protocol artifact? %o', {
            protocolFilePath,
            captureUploadUrl,
            protocolManager: !!protocolManager,
            fatalError: protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.hasFatalError(),
            shouldAddProtocolArtifact,
        });
        if (shouldAddProtocolArtifact) {
            const protocolArtifact = await (0, protocol_artifact_1.createProtocolArtifact)(protocolFilePath, captureUploadUrl, protocolManager);
            debug(protocolArtifact);
            if (protocolArtifact) {
                artifacts.push(protocolArtifact);
            }
        }
        else if (protocolCaptureMeta.url && !captureUploadUrl) {
            const err = new Error('Invalid or missing Test Replay upload URL');
            protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.addFatalError('protocolUploadUrl', err);
        }
    }
    catch (e) {
        debug('Error creating protocol artifact: %O', e);
    }
    return artifacts;
};
const uploadArtifacts = async (options) => {
    const { protocolManager, protocolCaptureMeta, quiet, runId, instanceId, spec, platform, projectId } = options;
    const priority = {
        [artifact_1.ArtifactKinds.VIDEO]: 0,
        [artifact_1.ArtifactKinds.SCREENSHOTS]: 1,
        [artifact_1.ArtifactKinds.PROTOCOL]: 2,
    };
    // Checking protocol fatal errors here, because if there is no fatal error
    // but protocol is enabled and there is no archive path, we want to detect
    // and establish a fatal error
    const preArtifactExtractionFatalError = protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getFatalError();
    /**
     * sometimes, protocolManager initializes both without an archive path and without recording an internal
     * fatal error. Test Replay initialization should be refactored in order to capture this state more appropriately.
     */
    debug({
        archivePath: protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getArchivePath(),
        protocolManager: !!protocolManager,
        preArtifactExtractionFatalError,
        protocolCaptureMeta,
    });
    if (protocolManager && (!protocolManager.getArchivePath() && !preArtifactExtractionFatalError && !protocolCaptureMeta.disabledMessage && protocolCaptureMeta.url)) {
        protocolManager.addFatalError('UNKNOWN', new Error('Unable to determine Test Replay archive location'));
    }
    const artifacts = (await extractArtifactsFromOptions(options)).sort((a, b) => {
        return priority[a.reportKey] - priority[b.reportKey];
    });
    let uploadReport = { video: undefined, screenshots: [], protocol: undefined };
    const postArtifactExtractionFatalError = protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getFatalError();
    if (postArtifactExtractionFatalError) {
        if (postArtifactExtractionFatalError.captureMethod === 'protocolUploadUrl') {
            errors.warning('CLOUD_PROTOCOL_CANNOT_UPLOAD_ARTIFACT', postArtifactExtractionFatalError.error);
        }
        else if ((0, types_1.isProtocolInitializationError)(postArtifactExtractionFatalError)) {
            errors.warning('CLOUD_PROTOCOL_INITIALIZATION_FAILURE', postArtifactExtractionFatalError.error);
        }
        else {
            errors.warning('CLOUD_PROTOCOL_CAPTURE_FAILURE', postArtifactExtractionFatalError.error);
        }
    }
    if (!quiet) {
        debug('logging upload manifest: %O', {
            artifacts,
            protocolCaptureMeta,
            fatalProtocolError: protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getFatalError(),
        });
        (0, print_run_1.logUploadManifest)(artifacts, protocolCaptureMeta, protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getFatalError());
    }
    debug('preparing to upload artifacts: %O', artifacts);
    let stopUploadActivityOutput;
    if (!quiet && artifacts.length) {
        stopUploadActivityOutput = (0, print_run_1.beginUploadActivityOutput)();
    }
    try {
        const uploadResults = await Promise.all(artifacts.map((artifact) => artifact.upload())).finally(() => {
            if (stopUploadActivityOutput) {
                stopUploadActivityOutput();
            }
        });
        if (!quiet && uploadResults.length) {
            (0, print_run_1.logUploadResults)(uploadResults, protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getFatalError());
        }
        const postUploadProtocolFatalError = protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.getFatalError();
        if (postUploadProtocolFatalError && postUploadProtocolFatalError.captureMethod === 'uploadCaptureArtifact') {
            const error = postUploadProtocolFatalError.error;
            (0, print_protocol_upload_error_1.printProtocolUploadError)(error);
        }
        // there is no upload results entry for protocol if we did not attempt to upload protocol due to a fatal error
        // during initialization or capture. however, we still want to report this failure with the rest of the upload
        // results, so we extract what the upload failure report should be from the options passed to this fn
        if (!uploadResults.find((result) => {
            return result.key === artifact_1.ArtifactKinds.PROTOCOL;
        }) && postUploadProtocolFatalError) {
            debug('composing error report from options');
            uploadResults.push(await (0, protocol_artifact_1.composeProtocolErrorReportFromOptions)(options));
        }
        uploadReport = uploadResults.reduce(toUploadReportPayload, { video: undefined, screenshots: [], protocol: undefined });
    }
    catch (err) {
        debug('primary try/catch failure, ', err.stack);
        errors.warning('CLOUD_CANNOT_UPLOAD_ARTIFACTS', err);
        await exception_1.default.create(err);
    }
    debug('checking for protocol errors', protocolManager === null || protocolManager === void 0 ? void 0 : protocolManager.hasErrors());
    if (protocolManager) {
        try {
            await protocolManager.reportNonFatalErrors({
                specName: spec.name,
                osName: platform.osName,
                projectSlug: projectId,
            });
        }
        catch (err) {
            debug('Failed to send protocol errors %O', err);
        }
    }
    try {
        debug('upload report: %O', uploadReport);
        const res = await api_1.default.updateInstanceArtifacts({
            runId, instanceId,
        }, uploadReport);
        return res;
    }
    catch (err) {
        debug('failed updating artifact status %o', {
            stack: err.stack,
        });
        // eslint-disable-next-line no-console
        console.log('');
        errors.warning('CLOUD_CANNOT_CONFIRM_ARTIFACTS', err);
        if (err.statusCode !== 503) {
            return exception_1.default.create(err);
        }
    }
};
exports.uploadArtifacts = uploadArtifacts;
