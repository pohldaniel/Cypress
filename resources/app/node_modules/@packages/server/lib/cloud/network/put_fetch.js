"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.putFetch = exports.ParseKinds = void 0;
const tslib_1 = require("tslib");
const cross_fetch_1 = tslib_1.__importDefault(require("cross-fetch"));
const system_error_1 = require("./system_error");
const http_error_1 = require("./http_error");
const parse_error_1 = require("./parse_error");
const network_1 = require("../../../../network");
const debug_1 = tslib_1.__importDefault(require("debug"));
const debug = (0, debug_1.default)('cypress-verbose:server:cloud:api:put');
exports.ParseKinds = Object.freeze({
    JSON: 'json',
    TEXT: 'text',
});
async function putFetch(input, options = { parse: 'json' }) {
    var _a;
    const { parse, ...init } = options;
    debug('Initiating PUT %s', input);
    try {
        const response = await (0, cross_fetch_1.default)(input, {
            ...(init || {}),
            method: 'PUT',
            // cross-fetch thinks this is in the browser, so declares
            // types based on that rather than on node-fetch which it
            // actually uses under the hood. node-fetch supports `agent`.
            // @ts-expect-error
            agent: network_1.agent,
        });
        if (response.status >= 400) {
            const err = await http_error_1.HttpError.fromResponse(response);
            throw err;
        }
        try {
            switch (parse) {
                case exports.ParseKinds.JSON:
                    return await response.json();
                case exports.ParseKinds.TEXT:
                    return await response.text();
                default:
                    return response.body;
            }
        }
        catch (e) {
            const parseError = new parse_error_1.ParseError(e, e.message);
            parseError.stack = e.stack;
            throw parseError;
        }
    }
    catch (e) {
        const err = ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) ? options.signal.reason : e;
        debug('Error (sys error? %s) %O', err.errno || err.code, err);
        if (parse_error_1.ParseError.isParseError(err) || http_error_1.HttpError.isHttpError(err)) {
            throw err;
        }
        // if the error has a syscall, it's a system error
        if (err.errno || err.code) {
            const url = typeof input === 'string' ? input :
                input instanceof URL ? input.href :
                    input instanceof Request ? input.url : 'UNKNOWN_URL';
            const sysError = new system_error_1.SystemError(err, url);
            sysError.stack = err.stack;
            throw sysError;
        }
        throw err;
    }
}
exports.putFetch = putFetch;
