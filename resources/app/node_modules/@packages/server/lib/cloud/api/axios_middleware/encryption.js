"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.installEncryption = void 0;
const tslib_1 = require("tslib");
const enc = tslib_1.__importStar(require("../../encryption"));
const constants_1 = require("../../constants");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const cloud_request_errors_1 = require("../cloud_request_errors");
const axios_1 = tslib_1.__importDefault(require("axios"));
let encryptionKey;
const encryptRequest = async (req) => {
    if (!req.data) {
        throw new Error(`Cannot issue encrypted request to ${req.url} without request body`);
    }
    encryptionKey !== null && encryptionKey !== void 0 ? encryptionKey : (encryptionKey = crypto_1.default.createSecretKey(Uint8Array.from(crypto_1.default.randomBytes(32))));
    const { jwe } = await enc.encryptRequest({ body: req.data }, { secretKey: encryptionKey });
    req.headers.set('x-cypress-encrypted', constants_1.PUBLIC_KEY_VERSION);
    req.data = jwe;
    return req;
};
const signRequest = (req) => {
    req.headers.set('x-cypress-signature', constants_1.PUBLIC_KEY_VERSION);
    return req;
};
const maybeDecryptResponse = async (res) => {
    if (!res.config.encrypt) {
        return res;
    }
    if (res.config.encrypt === 'always' || res.headers['x-cypress-encrypted']) {
        try {
            res.data = await enc.decryptResponse(res.data, encryptionKey);
        }
        catch (e) {
            throw new cloud_request_errors_1.DecryptionError(e.message);
        }
    }
    return res;
};
const maybeDecryptErrorResponse = async (err) => {
    var _a, _b, _c;
    if (axios_1.default.isAxiosError(err) && ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data)) {
        if (((_b = err.config) === null || _b === void 0 ? void 0 : _b.encrypt) === 'always' || ((_c = err.response) === null || _c === void 0 ? void 0 : _c.headers['x-cypress-encrypted'])) {
            try {
                if (err.response.data) {
                    err.response.data = await enc.decryptResponse(err.response.data, encryptionKey);
                }
            }
            catch (e) {
                if (err.status && err.status >= 500 || err.status === 404) {
                    throw err;
                }
                throw new cloud_request_errors_1.DecryptionError(e.message);
            }
        }
    }
    throw err;
};
const maybeVerifyResponseSignature = (res) => {
    if (res.config.encrypt === 'signed' && !res.headers['x-cypress-signature']) {
        throw new Error(`Expected signed response for ${res.config.url}`);
    }
    if (res.headers['x-cypress-signature']) {
        const dataString = typeof res.data === 'string' ? res.data : JSON.stringify(res.data);
        const verified = enc.verifySignature(dataString, res.headers['x-cypress-signature']);
        if (!verified) {
            throw new Error(`Unable to verify response signature for ${res.config.url}`);
        }
    }
    return res;
};
// Always = req & res MUST be encrypted
// true = req MUST be encrypted, res MAY be encrypted, signified by header
// signed = verify signature of the response body
const installEncryption = (axios) => {
    axios.interceptors.request.use(encryptRequest, undefined, {
        runWhen(config) {
            return config.encrypt === true || config.encrypt === 'always';
        },
    });
    axios.interceptors.request.use(signRequest, undefined, {
        runWhen(config) {
            return config.encrypt === 'signed';
        },
    });
    axios.interceptors.response.use(maybeDecryptResponse, maybeDecryptErrorResponse);
    axios.interceptors.response.use(maybeVerifyResponseSignature);
};
exports.installEncryption = installEncryption;
