"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _ = require('lodash');
const os = require('os');
const debug = require('debug')('cypress:server:cloud:api');
const debugProtocol = require('debug')('cypress:server:protocol');
const request = require('@cypress/request-promise');
const humanInterval = require('human-interval');
const RequestErrors = require('@cypress/request-promise/errors');
const pkg = require('../../../../root');
const machineId = require('../machine_id');
const errors = require('../../errors');
const bluebird_1 = tslib_1.__importDefault(require("bluebird"));
const agent_1 = tslib_1.__importDefault(require("../../../../network/lib/agent"));
const routes_1 = require("../routes");
const status_code_1 = require("../../util/status_code");
const enc = tslib_1.__importStar(require("../encryption"));
const environment_1 = tslib_1.__importDefault(require("../environment"));
const fs_1 = require("../../util/fs");
const protocol_1 = tslib_1.__importDefault(require("../protocol"));
const constants_1 = require("../constants");
const transform_error_1 = require("./axios_middleware/transform_error");
const cloud_request_errors_1 = require("./cloud_request_errors");
const THIRTY_SECONDS = humanInterval('30 seconds');
const SIXTY_SECONDS = humanInterval('60 seconds');
const TWO_MINUTES = humanInterval('2 minutes');
function retryDelays() {
    return process.env.API_RETRY_INTERVALS
        ? process.env.API_RETRY_INTERVALS.split(',').map(_.toNumber)
        : [THIRTY_SECONDS, SIXTY_SECONDS, TWO_MINUTES];
}
const runnerCapabilities = {
    'dynamicSpecsInSerialMode': true,
    'skipSpecAction': true,
    'protocolMountVersion': 2,
};
let responseCache = {};
const CAPTURE_ERRORS = !process.env.CYPRESS_LOCAL_PROTOCOL_PATH;
// TODO: migrate to fetch from @cypress/request
const rp = request.defaults((params, callback) => {
    var _a;
    let resp;
    if (params.cacheable && (resp = getCachedResponse(params))) {
        debug('resolving with cached response for %o', { url: params.url });
        return bluebird_1.default.resolve(resp);
    }
    _.defaults(params, {
        agent: agent_1.default,
        proxy: null,
        gzip: true,
        cacheable: false,
        encrypt: false,
        rejectUnauthorized: true,
    });
    const headers = (_a = params.headers) !== null && _a !== void 0 ? _a : (params.headers = {});
    _.defaults(headers, {
        'x-os-name': os.platform(),
        'x-cypress-version': pkg.version,
    });
    const method = params.method.toLowerCase();
    // use %j argument to ensure deep nested properties are serialized
    debug('request to url: %s with params: %j and token: %s', `${params.method} ${params.url}`, _.pick(params, 'body', 'headers'), params.auth && params.auth.bearer);
    return bluebird_1.default.try(async () => {
        // If we're encrypting the request, we generate the JWE
        // and set it to the JSON body for the request
        if (params.encrypt === true || params.encrypt === 'always') {
            const { secretKey, jwe } = await enc.encryptRequest(params);
            params.transform = async function (body, response) {
                const { statusCode } = response;
                const options = this; // request promise options
                const throwStatusCodeErrWithResp = (message, responseBody) => {
                    throw new RequestErrors.StatusCodeError(response.statusCode, message, options, responseBody);
                };
                // response is valid and we are encrypting
                if (response.headers['x-cypress-encrypted'] || params.encrypt === 'always') {
                    let decryptedBody;
                    try {
                        decryptedBody = await enc.decryptResponse(body, secretKey);
                    }
                    catch (e) {
                        // we failed decrypting the response...
                        // if status code is >=500 or 404 remove body
                        if (statusCode >= 500 || statusCode === 404) {
                            // remove server responses and replace with basic status code text
                            throwStatusCodeErrWithResp((0, status_code_1.getText)(statusCode), body);
                        }
                        throw new cloud_request_errors_1.DecryptionError(e.message);
                    }
                    // If we've hit an encrypted payload error case, we need to re-constitute the error
                    // as it would happen normally, with the body as an error property
                    if (response.statusCode > 400) {
                        throwStatusCodeErrWithResp(decryptedBody, decryptedBody);
                    }
                    return decryptedBody;
                }
                return body;
            };
            params.body = jwe;
            headers['x-cypress-encrypted'] = constants_1.PUBLIC_KEY_VERSION;
        }
        return request[method](params, callback).promise();
    })
        .tap((resp) => {
        if (params.cacheable) {
            debug('caching response for ', params.url);
            cacheResponse(resp, params);
        }
        return debug('response %o', resp);
    });
});
const cacheResponse = (resp, params) => {
    return responseCache[params.url] = resp;
};
const getCachedResponse = (params) => {
    return responseCache[params.url];
};
const retryWithBackoff = (fn) => {
    if (process.env.DISABLE_API_RETRIES) {
        debug('api retries disabled');
        return bluebird_1.default.try(() => fn(0));
    }
    const attempt = (retryIndex) => {
        return bluebird_1.default
            .try(() => fn(retryIndex))
            .catch(RequestErrors.TransformError, (err) => {
            // Unroll the error thrown from within the transform
            throw err.cause;
        })
            .catch(isRetriableError, (err) => {
            const delays = retryDelays();
            if (retryIndex >= delays.length) {
                throw err;
            }
            const delayMs = delays[retryIndex];
            errors.warning('CLOUD_API_RESPONSE_FAILED_RETRYING', {
                delayMs,
                tries: delays.length - retryIndex,
                response: err,
            });
            retryIndex++;
            return bluebird_1.default
                .delay(delayMs)
                .then(() => {
                debug(`retry #${retryIndex} after ${delayMs}ms`);
                return attempt(retryIndex);
            });
        });
    };
    return attempt(0);
};
const tagError = function (err) {
    err.isApiError = true;
    throw err;
};
// retry on timeouts, 5xx errors, or any error without a status code
// including decryption errors
const isRetriableError = (err) => {
    if (err instanceof cloud_request_errors_1.DecryptionError) {
        return false;
    }
    return err instanceof bluebird_1.default.TimeoutError ||
        (err.statusCode >= 500 && err.statusCode < 600) ||
        (err.statusCode == null);
};
function noProxyPreflightTimeout() {
    try {
        const timeoutFromEnv = Number(process.env.CYPRESS_INITIAL_PREFLIGHT_TIMEOUT);
        return isNaN(timeoutFromEnv) ? 5000 : timeoutFromEnv;
    }
    catch (e) {
        return 5000;
    }
}
let preflightResult = {
    encrypt: true,
};
let recordRoutes = routes_1.apiRoutes;
// Potential todos: Refactor to named exports, refactor away from `this.` in exports,
// move individual exports to their own files & convert this to barrelfile
exports.default = {
    rp,
    // For internal testing
    setPreflightResult(toSet) {
        preflightResult = {
            ...preflightResult,
            ...toSet,
        };
    },
    resetPreflightResult() {
        recordRoutes = routes_1.apiRoutes;
        preflightResult = {
            encrypt: true,
        };
    },
    ping() {
        return rp.get(routes_1.apiRoutes.ping())
            .catch(tagError);
    },
    getAuthUrls() {
        return rp.get({
            url: routes_1.apiRoutes.auth(),
            json: true,
            cacheable: true,
            headers: {
                'x-route-version': '2',
            },
        })
            .catch(tagError);
    },
    createRun(options) {
        const preflightOptions = _.pick(options, ['projectId', 'projectRoot', 'ciBuildId', 'browser', 'testingType', 'parallel', 'timeout']);
        return this.sendPreflight(preflightOptions)
            .then((result) => {
            const { warnings } = result;
            return retryWithBackoff((attemptIndex) => {
                var _a;
                const body = {
                    ..._.pick(options, [
                        'autoCancelAfterFailures',
                        'ci',
                        'specs',
                        'commit',
                        'group',
                        'platform',
                        'parallel',
                        'ciBuildId',
                        'projectId',
                        'recordKey',
                        'specPattern',
                        'tags',
                        'testingType',
                    ]),
                    runnerCapabilities,
                };
                return rp.post({
                    body,
                    url: recordRoutes.runs(),
                    json: true,
                    encrypt: preflightResult.encrypt,
                    timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : SIXTY_SECONDS,
                    headers: {
                        'x-route-version': '4',
                        'x-cypress-request-attempt': attemptIndex,
                    },
                })
                    .tap((result) => {
                    var _a;
                    // Tack on any preflight warnings prior to run warnings
                    if (warnings) {
                        result.warnings = warnings.concat((_a = result.warnings) !== null && _a !== void 0 ? _a : []);
                    }
                });
            });
        })
            .then(async (result) => {
            var _a;
            const protocolManager = new protocol_1.default();
            const captureProtocolUrl = ((_a = result.capture) === null || _a === void 0 ? void 0 : _a.url) || result.captureProtocolUrl;
            options.project.protocolManager = protocolManager;
            debugProtocol({ captureProtocolUrl });
            let script;
            try {
                const protocolUrl = captureProtocolUrl || process.env.CYPRESS_LOCAL_PROTOCOL_PATH;
                if (protocolUrl) {
                    script = await this.getCaptureProtocolScript(protocolUrl);
                }
            }
            catch (e) {
                debugProtocol('Error downloading capture code', e);
                const error = new Error(`Error downloading capture code: ${e.message}`);
                if (CAPTURE_ERRORS) {
                    protocolManager.addFatalError('getCaptureProtocolScript', error, [result.captureProtocolUrl]);
                }
                else {
                    throw e;
                }
            }
            if (script) {
                const config = options.project.getConfig();
                await options.project.protocolManager.prepareAndSetupProtocol(script, {
                    runId: result.runId,
                    projectId: options.projectId,
                    testingType: options.testingType,
                    cloudApi: {
                        url: routes_1.apiUrl,
                        retryWithBackoff: this.retryWithBackoff,
                        requestPromise: this.rp,
                    },
                    projectConfig: _.pick(config, ['devServerPublicPathRoute', 'port', 'proxyUrl', 'namespace']),
                    mountVersion: runnerCapabilities.protocolMountVersion,
                    debugData: options.project.configDebugData,
                    mode: 'record',
                });
            }
            return result;
        })
            .catch(RequestErrors.StatusCodeError, transform_error_1.transformError)
            .catch(tagError);
    },
    createInstance(runId, body, timeout) {
        return retryWithBackoff((attemptIndex) => {
            return rp.post({
                body,
                url: recordRoutes.instances(runId),
                json: true,
                encrypt: preflightResult.encrypt,
                timeout: timeout !== null && timeout !== void 0 ? timeout : SIXTY_SECONDS,
                headers: {
                    'x-route-version': '5',
                    'x-cypress-run-id': runId,
                    'x-cypress-request-attempt': attemptIndex,
                },
            })
                .catch(RequestErrors.StatusCodeError, transform_error_1.transformError)
                .catch(tagError);
        });
    },
    postInstanceTests(options) {
        const { instanceId, runId, timeout, ...body } = options;
        return retryWithBackoff((attemptIndex) => {
            return rp.post({
                url: recordRoutes.instanceTests(instanceId),
                json: true,
                encrypt: preflightResult.encrypt,
                timeout: timeout !== null && timeout !== void 0 ? timeout : SIXTY_SECONDS,
                headers: {
                    'x-route-version': '1',
                    'x-cypress-run-id': runId,
                    'x-cypress-request-attempt': attemptIndex,
                },
                body,
            })
                .catch(RequestErrors.StatusCodeError, transform_error_1.transformError)
                .catch(tagError);
        });
    },
    updateInstanceStdout(options) {
        return retryWithBackoff((attemptIndex) => {
            var _a;
            return rp.put({
                url: recordRoutes.instanceStdout(options.instanceId),
                json: true,
                timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : SIXTY_SECONDS,
                body: {
                    stdout: options.stdout,
                },
                headers: {
                    'x-cypress-run-id': options.runId,
                    'x-cypress-request-attempt': attemptIndex,
                },
            })
                .catch(RequestErrors.StatusCodeError, transform_error_1.transformError)
                .catch(tagError);
        });
    },
    updateInstanceArtifacts(options, body) {
        debug('PUT %s %o', recordRoutes.instanceArtifacts(options.instanceId), body);
        return retryWithBackoff((attemptIndex) => {
            var _a;
            return rp.put({
                url: recordRoutes.instanceArtifacts(options.instanceId),
                json: true,
                timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : SIXTY_SECONDS,
                body,
                headers: {
                    'x-route-version': '1',
                    'x-cypress-run-id': options.runId,
                    'x-cypress-request-attempt': attemptIndex,
                },
            })
                .catch(RequestErrors.StatusCodeError, transform_error_1.transformError)
                .catch(tagError);
        });
    },
    postInstanceResults(options) {
        return retryWithBackoff((attemptIndex) => {
            var _a;
            return rp.post({
                url: recordRoutes.instanceResults(options.instanceId),
                json: true,
                encrypt: preflightResult.encrypt,
                timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : SIXTY_SECONDS,
                headers: {
                    'x-route-version': '1',
                    'x-cypress-run-id': options.runId,
                    'x-cypress-request-attempt': attemptIndex,
                },
                body: _.pick(options, [
                    'stats',
                    'tests',
                    'exception',
                    'video',
                    'screenshots',
                    'reporterStats',
                    'metadata',
                ]),
            })
                .catch(RequestErrors.StatusCodeError, transform_error_1.transformError)
                .catch(tagError);
        });
    },
    createCrashReport(body, authToken, timeout = 3000) {
        return rp.post({
            url: routes_1.apiRoutes.exceptions(),
            json: true,
            body,
            auth: {
                bearer: authToken,
            },
        })
            .timeout(timeout)
            .catch(tagError);
    },
    postLogout(authToken) {
        return bluebird_1.default.join(this.getAuthUrls(), machineId.machineId(), (urls, machineId) => {
            return rp.post({
                url: urls.dashboardLogoutUrl,
                json: true,
                auth: {
                    bearer: authToken,
                },
                headers: {
                    'x-machine-id': machineId,
                },
            })
                .catch({ statusCode: 401 }, () => { }) // do nothing on 401
                .catch(tagError);
        });
    },
    clearCache() {
        responseCache = {};
    },
    sendPreflight(preflightInfo) {
        return retryWithBackoff(async (attemptIndex) => {
            const { projectRoot, timeout, ...preflightRequestBody } = preflightInfo;
            const preflightBaseProxy = routes_1.apiUrl.replace('api', 'api-proxy');
            const envInformation = await (0, environment_1.default)(projectRoot, process.pid.toString());
            const makeReq = (baseUrl, agent, timeout) => {
                return rp.post({
                    url: `${baseUrl}preflight`,
                    body: {
                        apiUrl: routes_1.apiUrl,
                        envUrl: envInformation.envUrl,
                        dependencies: envInformation.dependencies,
                        errors: envInformation.errors,
                        ...preflightRequestBody,
                    },
                    headers: {
                        'x-route-version': '1',
                        'x-cypress-request-attempt': attemptIndex,
                    },
                    timeout,
                    json: true,
                    encrypt: 'always',
                    agent,
                })
                    .catch(RequestErrors.TransformError, (err) => {
                    // Unroll the error thrown from within the transform
                    throw err.cause;
                });
            };
            const postReqs = async () => {
                const initialPreflightTimeout = noProxyPreflightTimeout();
                if (initialPreflightTimeout >= 0) {
                    try {
                        return await makeReq(preflightBaseProxy, null, initialPreflightTimeout);
                    }
                    catch (err) {
                        if (err.statusCode === 412) {
                            throw err;
                        }
                    }
                }
                return makeReq(routes_1.apiUrl, agent_1.default, timeout);
            };
            const result = await postReqs();
            preflightResult = result; // { encrypt: boolean, apiUrl: string }
            recordRoutes = (0, routes_1.makeRoutes)(result.apiUrl);
            return result;
        });
    },
    async getCaptureProtocolScript(url) {
        // TODO(protocol): Ensure this is removed in production
        if (process.env.CYPRESS_LOCAL_PROTOCOL_PATH) {
            debugProtocol(`Loading protocol via script at local path %s`, process.env.CYPRESS_LOCAL_PROTOCOL_PATH);
            return fs_1.fs.promises.readFile(process.env.CYPRESS_LOCAL_PROTOCOL_PATH, 'utf8');
        }
        const res = await retryWithBackoff(async (attemptIndex) => {
            return rp.get({
                url,
                headers: {
                    'x-route-version': '1',
                    'x-cypress-request-attempt': attemptIndex,
                    'x-cypress-signature': constants_1.PUBLIC_KEY_VERSION,
                },
                agent: agent_1.default,
                encrypt: 'signed',
                resolveWithFullResponse: true,
            });
        });
        const verified = enc.verifySignature(res.body, res.headers['x-cypress-signature']);
        if (!verified) {
            debugProtocol(`Unable to verify protocol signature %s`, url);
            throw new Error('Unable to verify protocol signature');
        }
        debugProtocol(`Loaded protocol via url %s`, url);
        return res.body;
    },
    retryWithBackoff,
    runnerCapabilities,
};
