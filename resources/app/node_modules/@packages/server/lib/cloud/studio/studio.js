"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StudioManager = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const require_script_1 = require("../require_script");
const path_1 = tslib_1.__importDefault(require("path"));
const report_studio_error_1 = require("../api/studio/report_studio_error");
const debug = (0, debug_1.default)('cypress:server:studio');
class StudioManager {
    constructor() {
        this.status = 'NOT_INITIALIZED';
    }
    static createInErrorManager({ cloudApi, studioHash, projectSlug, error, studioMethod, studioMethodArgs }) {
        const manager = new StudioManager();
        manager.status = 'IN_ERROR';
        (0, report_studio_error_1.reportStudioError)({
            cloudApi,
            studioHash,
            projectSlug,
            error,
            studioMethod,
            studioMethodArgs,
        });
        return manager;
    }
    async setup({ script, studioPath, studioHash, projectSlug, cloudApi, shouldEnableStudio }) {
        const { createStudioServer } = (0, require_script_1.requireScript)(script).default;
        this._studioServer = await createStudioServer({
            studioHash,
            studioPath,
            projectSlug,
            cloudApi,
            betterSqlite3Path: path_1.default.dirname(require.resolve('better-sqlite3/package.json')),
        });
        this.status = shouldEnableStudio ? 'ENABLED' : 'INITIALIZED';
    }
    initializeRoutes(router) {
        if (this._studioServer) {
            this.invokeSync('initializeRoutes', { isEssential: true }, router);
        }
    }
    async captureStudioEvent(event) {
        if (this._studioServer) {
            // this request is not essential - we don't want studio to error out if a telemetry request fails
            return (await this.invokeAsync('captureStudioEvent', { isEssential: false }, event));
        }
        return Promise.resolve();
    }
    addSocketListeners(socket) {
        if (this._studioServer) {
            this.invokeSync('addSocketListeners', { isEssential: true }, socket);
        }
    }
    async canAccessStudioAI(browser) {
        var _a;
        return (_a = (await this.invokeAsync('canAccessStudioAI', { isEssential: true }, browser))) !== null && _a !== void 0 ? _a : false;
    }
    async initializeStudioAI(options) {
        await this.invokeAsync('initializeStudioAI', { isEssential: true }, options);
    }
    updateSessionId(sessionId) {
        if (this._studioServer && typeof this._studioServer.updateSessionId === 'function') {
            this.invokeSync('updateSessionId', { isEssential: false }, sessionId);
        }
        else {
            debug('updateSessionId method not available on studio server');
        }
    }
    async destroy() {
        await this.invokeAsync('destroy', { isEssential: true });
    }
    reportError(error, studioMethod, ...studioMethodArgs) {
        var _a;
        try {
            (_a = this._studioServer) === null || _a === void 0 ? void 0 : _a.reportError(error, studioMethod, ...studioMethodArgs);
        }
        catch (e) {
            // If we fail to report the error, we shouldn't try and report it again
            debug(`Error calling StudioManager.reportError: %o, original error %o`, e, error);
        }
    }
    /**
     * Abstracts invoking a synchronous method on the StudioServer instance, so we can handle
     * errors in a uniform way
     */
    invokeSync(method, { isEssential }, ...args) {
        if (!this._studioServer) {
            return;
        }
        try {
            // @ts-expect-error - TS not associating the method & args properly, even though we know it's correct
            return this._studioServer[method].apply(this._studioServer, args);
        }
        catch (error) {
            let actualError;
            if (!(error instanceof Error)) {
                actualError = new Error(String(error));
            }
            else {
                actualError = error;
            }
            this.status = 'IN_ERROR';
            this.reportError(actualError, method, ...args);
        }
    }
    get isProtocolEnabled() {
        return !!this.protocolManager;
    }
    /**
     * Abstracts invoking an asynchronous method on the StudioServer instance, so we can handle
     * errors in a uniform way
     */
    async invokeAsync(method, { isEssential }, ...args) {
        if (!this._studioServer) {
            return undefined;
        }
        try {
            // @ts-expect-error - TS not associating the method & args properly, even though we know it's correct
            return await this._studioServer[method].apply(this._studioServer, args);
        }
        catch (error) {
            let actualError;
            if (!(error instanceof Error)) {
                actualError = new Error(String(error));
            }
            else {
                actualError = error;
            }
            // only set error state if this request is essential
            if (isEssential) {
                this.status = 'IN_ERROR';
            }
            this.reportError(actualError, method, ...args);
            return undefined;
        }
    }
}
exports.StudioManager = StudioManager;
