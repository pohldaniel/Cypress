"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StudioLifecycleManager = void 0;
const tslib_1 = require("tslib");
const studio_1 = require("./studio");
const protocol_1 = require("../protocol");
const debug_1 = tslib_1.__importDefault(require("debug"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const api_1 = tslib_1.__importDefault(require("../api"));
const report_studio_error_1 = require("../api/studio/report_studio_error");
const cloud_request_1 = require("../api/cloud_request");
const is_retryable_error_1 = require("../network/is_retryable_error");
const async_retry_1 = require("../../util/async_retry");
const post_studio_session_1 = require("../api/studio/post_studio_session");
const path_1 = tslib_1.__importDefault(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const ensure_studio_bundle_1 = require("./ensure_studio_bundle");
const chokidar_1 = tslib_1.__importDefault(require("chokidar"));
const promises_1 = require("fs/promises");
const get_cloud_metadata_1 = require("../get_cloud_metadata");
const TelemetryReporter_1 = require("./telemetry/TelemetryReporter");
const TelemetryManager_1 = require("./telemetry/TelemetryManager");
const bundle_lifecycle_1 = require("./telemetry/constants/bundle-lifecycle");
const initialization_1 = require("./telemetry/constants/initialization");
const debug = (0, debug_1.default)('cypress:server:studio-lifecycle-manager');
const routes = require('../routes');
class StudioLifecycleManager {
    constructor() {
        this.listeners = [];
    }
    get cloudStudioRequested() {
        return !!(process.env.CYPRESS_ENABLE_CLOUD_STUDIO || process.env.CYPRESS_LOCAL_STUDIO_PATH);
    }
    /**
     * Initialize the studio manager and possibly set up protocol.
     * Also registers this instance in the data context.
     * @param projectId The project ID
     * @param cloudDataSource The cloud data source
     * @param cfg The project configuration
     * @param debugData Debug data for the configuration
     * @param ctx Data context to register this instance with
     */
    initializeStudioManager({ projectId, cloudDataSource, cfg, debugData, ctx, }) {
        debug('Initializing studio manager');
        // Register this instance in the data context
        ctx.update((data) => {
            data.studioLifecycleManager = this;
        });
        this.ctx = ctx;
        this.updateStatus('INITIALIZING');
        const studioManagerPromise = this.createStudioManager({
            projectId,
            cloudDataSource,
            cfg,
            debugData,
        }).catch(async (error) => {
            debug('Error during studio manager setup: %o', error);
            const { cloudUrl, cloudHeaders } = await (0, get_cloud_metadata_1.getCloudMetadata)(cloudDataSource);
            (0, report_studio_error_1.reportStudioError)({
                cloudApi: {
                    cloudUrl,
                    cloudHeaders,
                    CloudRequest: cloud_request_1.CloudRequest,
                    isRetryableError: is_retryable_error_1.isRetryableError,
                    asyncRetry: async_retry_1.asyncRetry,
                },
                studioHash: projectId,
                projectSlug: cfg.projectId,
                error,
                studioMethod: 'initializeStudioManager',
                studioMethodArgs: [],
            });
            this.updateStatus('IN_ERROR');
            // Clean up any registered listeners
            this.listeners = [];
            TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.BUNDLE_LIFECYCLE_END);
            (0, TelemetryReporter_1.reportTelemetry)(bundle_lifecycle_1.BUNDLE_LIFECYCLE_TELEMETRY_GROUP_NAMES.COMPLETE_BUNDLE_LIFECYCLE, {
                success: false,
            });
            return null;
        });
        this.studioManagerPromise = studioManagerPromise;
        this.setupWatcher({
            projectId,
            cloudDataSource,
            cfg,
            debugData,
        });
    }
    isStudioReady() {
        if (!this.studioManager) {
            TelemetryManager_1.telemetryManager.addGroupMetadata(initialization_1.INITIALIZATION_TELEMETRY_GROUP_NAMES.INITIALIZE_STUDIO, {
                studioRequestedBeforeReady: true,
            });
        }
        return !!this.studioManager;
    }
    async getStudio() {
        if (!this.studioManagerPromise) {
            throw new Error('Studio manager has not been initialized');
        }
        const studioManager = await this.studioManagerPromise;
        if (studioManager) {
            this.updateStatus(studioManager.status);
        }
        return studioManager;
    }
    async createStudioManager({ projectId, cloudDataSource, cfg, debugData, }) {
        var _a;
        let studioPath;
        let studioHash;
        (0, TelemetryReporter_1.initializeTelemetryReporter)({
            projectSlug: projectId,
            cloudDataSource,
        });
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.BUNDLE_LIFECYCLE_START);
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.POST_STUDIO_SESSION_START);
        const studioSession = await (0, post_studio_session_1.postStudioSession)({
            projectId,
        });
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.POST_STUDIO_SESSION_END);
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.ENSURE_STUDIO_BUNDLE_START);
        if (!process.env.CYPRESS_LOCAL_STUDIO_PATH) {
            // The studio hash is the last part of the studio URL, after the last slash and before the extension
            studioHash = (_a = studioSession.studioUrl.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0];
            studioPath = path_1.default.join(os_1.default.tmpdir(), 'cypress', 'studio', studioHash);
            let hashLoadingPromise = StudioLifecycleManager.hashLoadingMap.get(studioHash);
            if (!hashLoadingPromise) {
                hashLoadingPromise = (0, ensure_studio_bundle_1.ensureStudioBundle)({
                    studioUrl: studioSession.studioUrl,
                    studioPath,
                    projectId,
                });
                StudioLifecycleManager.hashLoadingMap.set(studioHash, hashLoadingPromise);
            }
            await hashLoadingPromise;
        }
        else {
            studioPath = process.env.CYPRESS_LOCAL_STUDIO_PATH;
            studioHash = 'local';
        }
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.ENSURE_STUDIO_BUNDLE_END);
        const serverFilePath = path_1.default.join(studioPath, 'server', 'index.js');
        const script = await (0, promises_1.readFile)(serverFilePath, 'utf8');
        const studioManager = new studio_1.StudioManager();
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.STUDIO_MANAGER_SETUP_START);
        const { cloudUrl, cloudHeaders } = await (0, get_cloud_metadata_1.getCloudMetadata)(cloudDataSource);
        await studioManager.setup({
            script,
            studioPath,
            studioHash,
            projectSlug: projectId,
            cloudApi: {
                cloudUrl,
                cloudHeaders,
                CloudRequest: cloud_request_1.CloudRequest,
                isRetryableError: is_retryable_error_1.isRetryableError,
                asyncRetry: async_retry_1.asyncRetry,
            },
            shouldEnableStudio: this.cloudStudioRequested,
        });
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.STUDIO_MANAGER_SETUP_END);
        if (studioManager.status === 'ENABLED') {
            debug('Cloud studio is enabled - setting up protocol');
            const protocolManager = new protocol_1.ProtocolManager();
            TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.STUDIO_PROTOCOL_GET_START);
            const script = await api_1.default.getCaptureProtocolScript(studioSession.protocolUrl);
            TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.STUDIO_PROTOCOL_GET_END);
            TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.STUDIO_PROTOCOL_PREPARE_START);
            await protocolManager.prepareProtocol(script, {
                runId: 'studio',
                projectId: cfg.projectId,
                testingType: cfg.testingType,
                cloudApi: {
                    url: routes.apiUrl,
                    retryWithBackoff: api_1.default.retryWithBackoff,
                    requestPromise: api_1.default.rp,
                },
                projectConfig: lodash_1.default.pick(cfg, ['devServerPublicPathRoute', 'port', 'proxyUrl', 'namespace']),
                mountVersion: api_1.default.runnerCapabilities.protocolMountVersion,
                debugData,
                mode: 'studio',
            });
            TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.STUDIO_PROTOCOL_PREPARE_END);
            studioManager.protocolManager = protocolManager;
        }
        else {
            debug('Cloud studio is not enabled - skipping protocol setup');
        }
        debug('Studio is ready');
        this.studioManager = studioManager;
        this.callRegisteredListeners();
        this.updateStatus(studioManager.status);
        TelemetryManager_1.telemetryManager.mark(bundle_lifecycle_1.BUNDLE_LIFECYCLE_MARK_NAMES.BUNDLE_LIFECYCLE_END);
        (0, TelemetryReporter_1.reportTelemetry)(bundle_lifecycle_1.BUNDLE_LIFECYCLE_TELEMETRY_GROUP_NAMES.COMPLETE_BUNDLE_LIFECYCLE, {
            success: true,
        });
        return studioManager;
    }
    callRegisteredListeners() {
        if (!this.studioManager) {
            throw new Error('Studio manager has not been initialized');
        }
        const studioManager = this.studioManager;
        debug('Calling all studio ready listeners');
        this.listeners.forEach((listener) => {
            listener(studioManager);
        });
        if (!process.env.CYPRESS_LOCAL_STUDIO_PATH) {
            this.listeners = [];
        }
    }
    setupWatcher({ projectId, cloudDataSource, cfg, debugData, }) {
        // Don't setup a watcher if the studio bundle is NOT local
        if (!process.env.CYPRESS_LOCAL_STUDIO_PATH) {
            return;
        }
        // Close the watcher if a previous watcher exists
        if (StudioLifecycleManager.watcher) {
            StudioLifecycleManager.watcher.removeAllListeners();
            StudioLifecycleManager.watcher.close().catch(() => { });
        }
        // Watch for changes to the studio bundle
        StudioLifecycleManager.watcher = chokidar_1.default.watch(path_1.default.join(process.env.CYPRESS_LOCAL_STUDIO_PATH, 'server', 'index.js'), {
            awaitWriteFinish: true,
        }).on('change', async () => {
            var _a;
            await ((_a = this.studioManager) === null || _a === void 0 ? void 0 : _a.destroy());
            this.studioManager = undefined;
            this.studioManagerPromise = this.createStudioManager({
                projectId,
                cloudDataSource,
                cfg,
                debugData,
            }).then((studioManager) => {
                // eslint-disable-next-line no-console
                console.log('Studio manager reloaded');
                return studioManager;
            }).catch((error) => {
                // eslint-disable-next-line no-console
                console.error('Error during reload of studio manager: %o', error);
                return null;
            });
        });
    }
    /**
     * Register a listener that will be called when the studio is ready
     * @param listener Function to call when studio is ready
     */
    registerStudioReadyListener(listener) {
        // if there is already a studio manager, call the listener immediately
        if (this.studioManager) {
            debug('Studio ready - calling listener immediately');
            listener(this.studioManager);
            // If the studio bundle is local, we need to register the listener
            // so that we can reload the studio when the bundle changes
            if (process.env.CYPRESS_LOCAL_STUDIO_PATH) {
                this.listeners.push(listener);
            }
        }
        else {
            debug('Studio not ready - registering studio ready listener');
            this.listeners.push(listener);
        }
    }
    updateStatus(status) {
        var _a;
        if (status === this.lastStatus) {
            debug('Studio status unchanged: %s', status);
            return;
        }
        debug('Studio status changed: %s â†’ %s', this.lastStatus, status);
        this.lastStatus = status;
        if (this.ctx) {
            (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.emitter.studioStatusChange();
        }
        else {
            debug('No ctx available, cannot emit studioStatusChange');
        }
    }
}
exports.StudioLifecycleManager = StudioLifecycleManager;
StudioLifecycleManager.hashLoadingMap = new Map();
StudioLifecycleManager.watcher = null;
