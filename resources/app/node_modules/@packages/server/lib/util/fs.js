"use strict";
/* eslint-disable no-console */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPath = exports.fs = void 0;
const tslib_1 = require("tslib");
const bluebird_1 = tslib_1.__importDefault(require("bluebird"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const sanitize_filename_1 = tslib_1.__importDefault(require("sanitize-filename"));
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const RUNNABLE_SEPARATOR = ' -- ';
const pathSeparatorRe = /[\\\/]/g;
// many filesystems limit filename length to 255 bytes/characters, so truncate the filename to
// the smallest common denominator of safe filenames, which is 255 bytes. when ENAMETOOLONG
// errors are encountered, `maxSafeBytes` will be decremented to at most `MIN_PREFIX_BYTES`, at
// which point the latest ENAMETOOLONG error will be emitted.
// @see https://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits
let maxSafeBytes = Number(process.env.CYPRESS_MAX_SAFE_FILENAME_BYTES) || 254;
const MIN_PREFIX_BYTES = 64;
exports.fs = bluebird_1.default.promisifyAll(fs_extra_1.default);
const ensureSafePath = async function (withoutExt, extension, overwrite, num = 0) {
    const suffix = `${(num && !overwrite) ? ` (${num})` : ''}.${extension}`;
    const maxSafePrefixBytes = maxSafeBytes - suffix.length;
    const filenameBuf = Buffer.from(path_1.default.basename(withoutExt));
    if (filenameBuf.byteLength > maxSafePrefixBytes) {
        const truncated = filenameBuf.slice(0, maxSafePrefixBytes).toString();
        withoutExt = path_1.default.join(path_1.default.dirname(withoutExt), truncated);
    }
    const fullPath = [withoutExt, suffix].join('');
    return exports.fs.pathExists(fullPath)
        .then((found) => {
        if (found && !overwrite) {
            return ensureSafePath(withoutExt, extension, overwrite, num + 1);
        }
        // path does not exist, attempt to create it to check for an ENAMETOOLONG error
        return exports.fs.outputFileAsync(fullPath, '')
            .then(() => fullPath)
            .catch((err) => {
            if (err.code === 'ENAMETOOLONG' && maxSafePrefixBytes >= MIN_PREFIX_BYTES) {
                maxSafeBytes -= 1;
                return ensureSafePath(withoutExt, extension, overwrite, num);
            }
            throw err;
        });
    });
};
const sanitizeToString = (title, idx, arr) => {
    // test titles may be values which aren't strings like
    // null or undefined - so convert before trying to sanitize
    return (0, sanitize_filename_1.default)(lodash_1.default.toString(title));
};
const getPath = async function (data, ext, screenshotsFolder, overwrite) {
    let names;
    const specNames = (data.specName || '')
        .split(pathSeparatorRe);
    if (data.name) {
        names = data.name.split(pathSeparatorRe).map(sanitizeToString);
    }
    else {
        // we put this in array so to match with type of the if branch above
        names = [lodash_1.default
                .chain(data.titles)
                .map(sanitizeToString)
                .join(RUNNABLE_SEPARATOR)
                .value()];
    }
    const index = names.length - 1;
    // append '(failed)' to the last name
    if (data.testFailure) {
        names[index] = `${names[index]} (failed)`;
    }
    if (data.testAttemptIndex && data.testAttemptIndex > 0) {
        names[index] = `${names[index]} (attempt ${data.testAttemptIndex + 1})`;
    }
    let withoutExt;
    if (screenshotsFolder) {
        withoutExt = path_1.default.join(screenshotsFolder, ...specNames, ...names);
    }
    else {
        withoutExt = path_1.default.join(...specNames, ...names);
    }
    return await ensureSafePath(withoutExt, ext, overwrite);
};
exports.getPath = getPath;
