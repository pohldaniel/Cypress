"use strict";
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
const lazy_ass_1 = tslib_1.__importDefault(require("lazy-ass"));
const check_more_types_1 = tslib_1.__importDefault(require("check-more-types"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const bluebird_1 = tslib_1.__importDefault(require("bluebird"));
const is_fork_pr_1 = tslib_1.__importDefault(require("is-fork-pr"));
const commit_info_1 = tslib_1.__importDefault(require("@cypress/commit-info"));
const telemetry_1 = require("../../../telemetry");
const config_1 = require("../../../config");
const api_1 = tslib_1.__importDefault(require("../cloud/api"));
const exception_1 = tslib_1.__importDefault(require("../cloud/exception"));
const errors_1 = require("../errors");
const capture_1 = tslib_1.__importDefault(require("../capture"));
const config_2 = require("../config");
const env_1 = tslib_1.__importDefault(require("../util/env"));
const ci_provider_1 = tslib_1.__importDefault(require("../util/ci_provider"));
const tests_utils_1 = require("../util/tests_utils");
const spec_writer_1 = require("../util/spec_writer");
const upload_artifacts_1 = require("../cloud/artifacts/upload_artifacts");
const debug = (0, debug_1.default)('cypress:server:record');
const debugCiInfo = (0, debug_1.default)('cypress:server:record:ci-info');
// dont yell about any errors either
const runningInternalTests = () => {
    return env_1.default.get('CYPRESS_INTERNAL_SYSTEM_TESTS') === '1';
};
const haveProjectIdAndKeyButNoRecordOption = (projectId, options) => {
    // if we have a project id and we have a key
    // and record hasn't been set to true or false
    return (projectId && options.key) && (lodash_1.default.isUndefined(options.record));
};
const warnIfProjectIdButNoRecordOption = (projectId, options) => {
    if (haveProjectIdAndKeyButNoRecordOption(projectId, options)) {
        // log a warning telling the user
        // that they either need to provide us
        // with a RECORD_KEY or turn off
        // record mode
        return (0, errors_1.warning)('PROJECT_ID_AND_KEY_BUT_MISSING_RECORD_OPTION', `${projectId}`);
    }
    return undefined;
};
function cloudCannotProceedErr({ parallel, ciBuildId, group, err }) {
    const errMsg = parallel ? 'CLOUD_CANNOT_PROCEED_IN_PARALLEL' : 'CLOUD_CANNOT_PROCEED_IN_SERIAL';
    const errToThrow = (0, errors_1.get)(errMsg, {
        response: err,
        flags: {
            group,
            ciBuildId,
        },
    });
    // tells error handler to exit immediately without running anymore specs
    errToThrow.isFatalApiErr = true;
    return errToThrow;
}
const throwCloudCannotProceed = (...args) => {
    throw cloudCannotProceedErr(...args);
};
const throwIfIndeterminateCiBuildId = (ciBuildId, parallel, group) => {
    if ((!ciBuildId && !ci_provider_1.default.provider()) && (parallel || group)) {
        (0, errors_1.throwErr)('INDETERMINATE_CI_BUILD_ID', {
            group,
            parallel: `${parallel}`,
        }, ci_provider_1.default.detectableCiBuildIdProviders());
    }
};
const throwIfRecordParamsWithoutRecording = (record, ciBuildId, parallel, group, tag, autoCancelAfterFailures) => {
    if (!record && lodash_1.default.some([ciBuildId, parallel, group, tag, autoCancelAfterFailures !== undefined])) {
        (0, errors_1.throwErr)('RECORD_PARAMS_WITHOUT_RECORDING', {
            ciBuildId,
            tag,
            group,
            parallel: `${parallel}`,
            autoCancelAfterFailures: `${autoCancelAfterFailures}`,
        });
    }
};
const throwIfIncorrectCiBuildIdUsage = (ciBuildId, parallel, group) => {
    // we've been given an explicit ciBuildId
    // but no parallel or group flag
    if (ciBuildId && (!parallel && !group)) {
        (0, errors_1.throwErr)('INCORRECT_CI_BUILD_ID_USAGE', { ciBuildId });
    }
};
const throwIfNoProjectId = (projectId, configFile) => {
    if (!projectId) {
        (0, errors_1.throwErr)('CANNOT_RECORD_NO_PROJECT_ID', configFile);
    }
};
const getSpecRelativePath = (spec) => {
    return lodash_1.default.get(spec, 'relative', null);
};
/*
artifacts : [
  {
    reportKey: 'protocol' | 'screenshots' | 'video',
    uploadUrl: string,
    filePath?: string,
    url: string,
    fileSize?: number | bigint,
    payload?: Buffer,
    message?: string,
  }
]

returns:
[
  {
    success: boolean,
    error?: string,
    url: artifact.uploadUrl,
    pathToFile: artifact.filePath,
    fileSize: artifact.fileSize,
    key: artifact.reportKey,
  },
  ...
]
*/
const updateInstanceStdout = async (options = {}) => {
    const { runId, instanceId, captured } = options;
    const stdout = captured.toString();
    return api_1.default.updateInstanceStdout({
        runId,
        stdout,
        instanceId,
    }).catch((err) => {
        debug('failed updating instance stdout %o', {
            stack: err.stack,
        });
        (0, errors_1.warning)('CLOUD_CANNOT_CREATE_RUN_OR_INSTANCE', err);
        // dont log exceptions if we have a 503 status code
        if (err.statusCode !== 503) {
            return exception_1.default.create(err);
        }
        return undefined;
    }).finally(capture_1.default.restore);
};
const postInstanceResults = (options = {}) => {
    const { runId, instanceId, results, group, parallel, ciBuildId, metadata } = options;
    let { stats, tests, video, screenshots, reporterStats, error } = results;
    video = Boolean(video);
    // get rid of the path property
    screenshots = lodash_1.default.map(screenshots, (screenshot) => {
        return lodash_1.default.omit(screenshot, 'path');
    });
    tests = tests && lodash_1.default.map(tests, (test) => {
        return lodash_1.default.omit({
            clientId: test.testId,
            ...test,
        }, 'title', 'body', 'testId');
    });
    return api_1.default.postInstanceResults({
        runId,
        instanceId,
        stats,
        tests,
        exception: error,
        video,
        reporterStats,
        screenshots,
        metadata,
    })
        .catch((err) => {
        debug('failed updating instance %o', {
            stack: err.stack,
        });
        throwCloudCannotProceed({ parallel, ciBuildId, group, err });
    });
};
const getCommitFromGitOrCi = (git) => {
    (0, lazy_ass_1.default)(check_more_types_1.default.object(git), 'expected git information object', git);
    return ci_provider_1.default.commitDefaults({
        sha: git.sha,
        branch: git.branch,
        authorName: git.author,
        authorEmail: git.email,
        message: git.message,
        remoteOrigin: git.remote,
        defaultBranch: null,
    });
};
const billingLink = (orgId) => {
    if (orgId) {
        return `https://on.cypress.io/dashboard/organizations/${orgId}/billing`;
    }
    return 'https://on.cypress.io/set-up-billing';
};
const gracePeriodMessage = (gracePeriodEnds) => {
    return gracePeriodEnds || 'the grace period ends';
};
const createRun = bluebird_1.default.method((options = {}) => {
    lodash_1.default.defaults(options, {
        group: null,
        tags: null,
        parallel: null,
        ciBuildId: null,
    });
    let { projectRoot, projectId, recordKey, platform, git, specPattern, specs, parallel, ciBuildId, group, tags, testingType, autoCancelAfterFailures, project } = options;
    if (recordKey == null) {
        recordKey = env_1.default.get('CYPRESS_RECORD_KEY');
    }
    if (!recordKey) {
        // are we a forked pull request (forked PR) and are we NOT running our own internal
        // e2e tests? currently some e2e tests fail when a user submits
        // a PR because this logic triggers unintended here
        if (is_fork_pr_1.default.isForkPr() && !runningInternalTests()) {
            // bail with a warning
            return (0, errors_1.warning)('RECORDING_FROM_FORK_PR');
        }
        // else throw
        (0, errors_1.throwErr)('RECORD_KEY_MISSING');
    }
    // go back to being a string
    if (Array.isArray(specPattern)) {
        specPattern = specPattern.join(',');
    }
    if (ciBuildId) {
        // stringify
        ciBuildId = String(ciBuildId);
    }
    specs = lodash_1.default.map(specs, getSpecRelativePath);
    const commit = getCommitFromGitOrCi(git);
    const ci = {
        params: ci_provider_1.default.ciParams(),
        provider: ci_provider_1.default.provider(),
    };
    // write git commit and CI provider information
    // in its own log source to expose separately
    debugCiInfo('commit information %o', commit);
    debugCiInfo('CI provider information %o', ci);
    return api_1.default.createRun({
        projectRoot,
        specs,
        group,
        tags,
        parallel,
        platform,
        ciBuildId,
        projectId,
        recordKey,
        specPattern,
        testingType,
        ci,
        commit,
        autoCancelAfterFailures,
        project,
    })
        .tap((response) => {
        if (!(response && response.warnings && response.warnings.length)) {
            return;
        }
        return lodash_1.default.each(response.warnings, (warning) => {
            switch (warning.code) {
                case 'FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_TESTS':
                    return (0, errors_1.warning)('FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_TESTS', {
                        limit: warning.limit,
                        usedTestsMessage: 'test',
                        gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),
                        link: billingLink(warning.orgId),
                    });
                case 'FREE_PLAN_IN_GRACE_PERIOD_PARALLEL_FEATURE':
                    return (0, errors_1.warning)('FREE_PLAN_IN_GRACE_PERIOD_PARALLEL_FEATURE', {
                        gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),
                        link: billingLink(warning.orgId),
                    });
                case 'FREE_PLAN_EXCEEDS_MONTHLY_TESTS_V2':
                    return (0, errors_1.warning)('PLAN_EXCEEDS_MONTHLY_TESTS', {
                        planType: 'free',
                        limit: warning.limit,
                        usedTestsMessage: 'test',
                        link: billingLink(warning.orgId),
                    });
                case 'PAID_PLAN_EXCEEDS_MONTHLY_TESTS':
                    return (0, errors_1.warning)('PLAN_EXCEEDS_MONTHLY_TESTS', {
                        planType: 'current',
                        limit: warning.limit,
                        usedTestsMessage: 'test',
                        link: billingLink(warning.orgId),
                    });
                case 'PLAN_IN_GRACE_PERIOD_RUN_GROUPING_FEATURE_USED':
                    return (0, errors_1.warning)('PLAN_IN_GRACE_PERIOD_RUN_GROUPING_FEATURE_USED', {
                        gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),
                        link: billingLink(warning.orgId),
                    });
                default:
                    return (0, errors_1.warning)('CLOUD_UNKNOWN_CREATE_RUN_WARNING', {
                        message: warning.message,
                        props: lodash_1.default.omit(warning, 'message'),
                    });
            }
        });
    }).catch((err) => {
        debug('failed creating run with status %o', lodash_1.default.pick(err, ['name', 'message', 'statusCode', 'stack']));
        switch (err.statusCode) {
            case 401:
                recordKey = (0, config_1.hideKeys)(recordKey);
                if (!recordKey) {
                    // make sure the key is defined, otherwise the error
                    // printing logic substitutes the default value {}
                    // leading to "[object Object]" :)
                    recordKey = 'undefined';
                }
                return (0, errors_1.throwErr)('CLOUD_RECORD_KEY_NOT_VALID', recordKey, projectId);
            case 402: {
                const { code, payload } = err.error;
                const limit = lodash_1.default.get(payload, 'limit');
                const orgId = lodash_1.default.get(payload, 'orgId');
                switch (code) {
                    case 'FREE_PLAN_EXCEEDS_MONTHLY_TESTS':
                        return (0, errors_1.throwErr)('FREE_PLAN_EXCEEDS_MONTHLY_TESTS', {
                            limit,
                            usedTestsMessage: 'test',
                            link: billingLink(orgId),
                        });
                    case 'PARALLEL_FEATURE_NOT_AVAILABLE_IN_PLAN':
                        return (0, errors_1.throwErr)('PARALLEL_FEATURE_NOT_AVAILABLE_IN_PLAN', {
                            link: billingLink(orgId),
                        });
                    case 'RUN_GROUPING_FEATURE_NOT_AVAILABLE_IN_PLAN':
                        return (0, errors_1.throwErr)('RUN_GROUPING_FEATURE_NOT_AVAILABLE_IN_PLAN', {
                            link: billingLink(orgId),
                        });
                    case 'AUTO_CANCEL_NOT_AVAILABLE_IN_PLAN':
                        return (0, errors_1.throwErr)('CLOUD_AUTO_CANCEL_NOT_AVAILABLE_IN_PLAN', {
                            link: billingLink(orgId),
                        });
                    default:
                        return (0, errors_1.throwErr)('CLOUD_UNKNOWN_INVALID_REQUEST', {
                            response: err,
                            flags: {
                                group,
                                tags,
                                parallel,
                                ciBuildId,
                            },
                        });
                }
            }
            case 404:
                return (0, errors_1.throwErr)('CLOUD_PROJECT_NOT_FOUND', projectId, path_1.default.basename(options.configFile));
            case 412:
                return (0, errors_1.throwErr)('CLOUD_INVALID_RUN_REQUEST', err.error);
            case 422: {
                const { code, payload } = err.error;
                const runUrl = lodash_1.default.get(payload, 'runUrl');
                switch (code) {
                    case 'RUN_GROUP_NAME_NOT_UNIQUE':
                        return (0, errors_1.throwErr)('CLOUD_RUN_GROUP_NAME_NOT_UNIQUE', {
                            group,
                            runUrl,
                            ciBuildId,
                        });
                    case 'PARALLEL_GROUP_PARAMS_MISMATCH': {
                        const { browserName, browserVersion, osName, osVersion } = platform;
                        return (0, errors_1.throwErr)('CLOUD_PARALLEL_GROUP_PARAMS_MISMATCH', {
                            group,
                            runUrl,
                            ciBuildId,
                            parameters: {
                                osName,
                                osVersion,
                                browserName,
                                browserVersion,
                                specs,
                            },
                            payload,
                        });
                    }
                    case 'PARALLEL_DISALLOWED':
                        return (0, errors_1.throwErr)('CLOUD_PARALLEL_DISALLOWED', {
                            tags,
                            group,
                            runUrl,
                            ciBuildId,
                        });
                    case 'PARALLEL_REQUIRED':
                        return (0, errors_1.throwErr)('CLOUD_PARALLEL_REQUIRED', {
                            tags,
                            group,
                            runUrl,
                            ciBuildId,
                        });
                    case 'ALREADY_COMPLETE':
                        return (0, errors_1.throwErr)('CLOUD_ALREADY_COMPLETE', {
                            runUrl,
                            tags,
                            group,
                            parallel,
                            ciBuildId,
                        });
                    case 'STALE_RUN':
                        return (0, errors_1.throwErr)('CLOUD_STALE_RUN', {
                            runUrl,
                            tags,
                            group,
                            parallel,
                            ciBuildId,
                        });
                    case 'AUTO_CANCEL_MISMATCH':
                        return (0, errors_1.throwErr)('CLOUD_AUTO_CANCEL_MISMATCH', {
                            runUrl,
                            tags,
                            group,
                            parallel,
                            ciBuildId,
                            autoCancelAfterFailures,
                        });
                    default:
                        return (0, errors_1.throwErr)('CLOUD_UNKNOWN_INVALID_REQUEST', {
                            response: err,
                            flags: {
                                tags,
                                group,
                                parallel,
                                ciBuildId,
                            },
                        });
                }
            }
            default:
                throwCloudCannotProceed({ parallel, ciBuildId, group, err });
        }
    });
});
async function createInstance(options) {
    let { spec, runId, group, groupId, parallel, machineId, ciBuildId, platform } = options;
    const resolvedSpec = spec ? getSpecRelativePath(spec) : null;
    try {
        return await api_1.default.createInstance(runId, {
            spec: resolvedSpec,
            groupId,
            platform,
            machineId,
        });
    }
    catch (thrown) {
        const err = thrown instanceof Error ? thrown : new Error(thrown);
        debug('failed creating instance %o', {
            stack: err.stack,
        });
        throw cloudCannotProceedErr({
            err,
            group,
            ciBuildId,
            parallel,
        });
    }
}
const _postInstanceTests = ({ runId, instanceId, config, tests, hooks, parallel, ciBuildId, group, }) => {
    return api_1.default.postInstanceTests({
        runId,
        instanceId,
        config,
        tests,
        hooks,
    })
        .catch((err) => {
        throwCloudCannotProceed({ parallel, ciBuildId, group, err });
    });
};
const createRunAndRecordSpecs = (options = {}) => {
    const { specPattern, specs, sys, browser, projectId, config, projectRoot, runAllSpecs, parallel, ciBuildId, group, project, onError, testingType, quiet, autoCancelAfterFailures, } = options;
    const recordKey = options.key;
    // we want to normalize this to an array to send to API
    const tags = lodash_1.default.split(options.tag, ',');
    return commit_info_1.default.commitInfo(projectRoot)
        .then((git) => {
        debugCiInfo('found the following git information');
        debugCiInfo(git);
        const platform = {
            osCpus: sys.osCpus,
            osName: sys.osName,
            osMemory: sys.osMemory,
            osVersion: sys.osVersion,
            browserName: browser.displayName,
            browserVersion: browser.version,
        };
        telemetry_1.telemetry.startSpan({ name: 'record:createRun' });
        // @ts-expect-error TODO: Fix this saying its expecting 0 args
        return createRun({
            projectRoot,
            git,
            specs,
            group,
            tags,
            parallel,
            platform,
            recordKey,
            ciBuildId,
            projectId,
            specPattern,
            testingType,
            configFile: config ? config.configFile : null,
            autoCancelAfterFailures,
            project,
        })
            .then((resp) => {
            var _a;
            (_a = telemetry_1.telemetry.getSpan('record:createRun')) === null || _a === void 0 ? void 0 : _a.end();
            if (!resp) {
                // if a forked run, can't record and can't be parallel
                // because the necessary env variables aren't present
                return runAllSpecs({
                    parallel: false,
                });
            }
            const { runUrl, runId, machineId, groupId } = resp;
            const protocolCaptureMeta = resp.capture || {};
            let captured = null;
            let instanceId = null;
            const beforeSpecRun = () => {
                telemetry_1.telemetry.startSpan({ name: 'record:beforeSpecRun' });
                project.setOnTestsReceived(onTestsReceived);
                capture_1.default.restore();
                captured = capture_1.default.stdout();
                return createInstance({
                    runId,
                    group,
                    groupId,
                    platform,
                    parallel,
                    ciBuildId,
                    machineId,
                })
                    .then((resp = {}) => {
                    var _a;
                    instanceId = resp.instanceId;
                    // pull off only what we need
                    const result = lodash_1.default
                        .chain(resp)
                        .pick('spec', 'claimedInstances', 'totalInstances')
                        .extend({
                        estimated: resp.estimatedWallClockDuration,
                        instanceId,
                    })
                        .value();
                    (_a = telemetry_1.telemetry.getSpan('record:beforeSpecRun')) === null || _a === void 0 ? void 0 : _a.end();
                    return result;
                });
            };
            const afterSpecRun = (spec, results, config) => {
                // don't do anything if we failed to
                // create the instance
                if (!instanceId || results.skippedSpec) {
                    return;
                }
                telemetry_1.telemetry.startSpan({ name: 'record:afterSpecRun' });
                debug('after spec run %o', { spec });
                return (0, spec_writer_1.countStudioUsage)(spec.absolute)
                    .then((metadata) => {
                    return postInstanceResults({
                        group,
                        config,
                        results,
                        parallel,
                        ciBuildId,
                        instanceId,
                        metadata,
                    });
                })
                    .then((resp) => {
                    if (!resp) {
                        return;
                    }
                    debug('postInstanceResults resp %O', resp);
                    const { video, screenshots } = results;
                    const { videoUploadUrl, captureUploadUrl, screenshotUploadUrls } = resp;
                    return (0, upload_artifacts_1.uploadArtifacts)({
                        runId,
                        // @ts-expect-error TODO: Fix this saying instanceId cannot be null here - we returned earlier if null
                        instanceId,
                        video,
                        screenshots,
                        videoUploadUrl,
                        captureUploadUrl,
                        platform,
                        projectId,
                        spec,
                        protocolCaptureMeta,
                        protocolManager: project.protocolManager,
                        screenshotUploadUrls,
                        quiet,
                    })
                        .finally(() => {
                        // always attempt to upload stdout
                        // even if uploading failed
                        return updateInstanceStdout({
                            captured,
                            instanceId,
                        }).finally(() => {
                            var _a;
                            (_a = telemetry_1.telemetry.getSpan('record:afterSpecRun')) === null || _a === void 0 ? void 0 : _a.end();
                        });
                    });
                });
            };
            const onTestsReceived = (async (runnables, cb) => {
                // we failed createInstance earlier, nothing to do
                if (!instanceId) {
                    return cb();
                }
                // runnables will be null when there' no tests
                // this also means runtimeConfig will be missing
                runnables = runnables || {};
                const r = (0, tests_utils_1.flattenSuiteIntoRunnables)(runnables);
                const runtimeConfig = runnables.runtimeConfig;
                const resolvedRuntimeConfig = (0, config_2.getResolvedRuntimeConfig)(config, runtimeConfig);
                const tests = lodash_1.default.chain(r[0])
                    .uniqBy('id')
                    .map((v) => {
                    var _a;
                    return lodash_1.default.pick({
                        ...v,
                        clientId: v.id,
                        config: ((_a = v._testConfig) === null || _a === void 0 ? void 0 : _a.unverifiedTestConfig) || null,
                        title: v._titlePath.map((title) => {
                            // sanitize the title which may have been altered by a suite-/test-level
                            // browser skip to ensure the original title is used so the test recorded
                            // to the cloud is correct registered as a pending test
                            const BROWSER_SKIP_TITLE = ' (skipped due to browser)';
                            return title.replace(BROWSER_SKIP_TITLE, '');
                        }),
                        hookIds: v.hooks.map((hook) => hook.hookId),
                    }, 'clientId', 'body', 'title', 'config', 'hookIds');
                })
                    .value();
                const hooks = lodash_1.default.chain(r[1])
                    .uniqBy('hookId')
                    .map((v) => {
                    return lodash_1.default.pick({
                        ...v,
                        clientId: v.hookId,
                        title: [v.title],
                        type: v.hookName,
                    }, 'clientId', 'type', 'title', 'body');
                })
                    .value();
                const responseDidFail = {};
                const response = await _postInstanceTests({
                    runId,
                    instanceId,
                    config: resolvedRuntimeConfig,
                    tests,
                    hooks,
                    parallel,
                    ciBuildId,
                    group,
                })
                    .catch((err) => {
                    onError(err);
                    return responseDidFail;
                });
                if (response === responseDidFail) {
                    debug('`responseDidFail` equals `response`, allowing browser to hang until it is killed: Response %o', { responseDidFail });
                    // dont call the cb, let the browser hang until it's killed
                    return;
                }
                if (lodash_1.default.some(response.actions, { type: 'SPEC', action: 'SKIP' })) {
                    (0, errors_1.warning)('CLOUD_CANCEL_SKIPPED_SPEC');
                    // set a property on the response so the browser runner
                    // knows not to start executing tests
                    project.emit('end', { skippedSpec: true, stats: {} });
                    // dont call the cb, let the browser hang until it's killed
                    return;
                }
                return cb(response);
            });
            return runAllSpecs({
                runUrl,
                parallel,
                onTestsReceived,
                beforeSpecRun,
                afterSpecRun,
            });
        });
    });
};
module.exports = {
    createRun,
    createInstance,
    postInstanceResults,
    _postInstanceTests,
    updateInstanceStdout,
    uploadArtifacts: upload_artifacts_1.uploadArtifacts,
    throwIfNoProjectId,
    throwIfIndeterminateCiBuildId,
    throwIfIncorrectCiBuildIdUsage,
    warnIfProjectIdButNoRecordOption,
    throwIfRecordParamsWithoutRecording,
    createRunAndRecordSpecs,
    getCommitFromGitOrCi,
};
