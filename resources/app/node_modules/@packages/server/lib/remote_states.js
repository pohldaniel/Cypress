"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteStates = exports.DEFAULT_DOMAIN_NAME = void 0;
const tslib_1 = require("tslib");
const network_1 = require("../../network");
const debug_1 = tslib_1.__importDefault(require("debug"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
exports.DEFAULT_DOMAIN_NAME = 'localhost';
const fullyQualifiedRe = /^https?:\/\//;
const debug = (0, debug_1.default)('cypress:server:remote-states');
/**
 * Class to maintain and manage the remote states of the server.
 *
 * Example file remote state:
 * {
 *   auth: {
 *     username: 'name'
 *     password: 'pass'
 *   }
 *   origin: "http://localhost:2020"
 *   fileServer: "http://localhost:2021"
 *   strategy: "file"
 *   domainName: "localhost"
 *   props: null
 * }
 *
 * Example http remote state:
 * {
 *   auth: {
 *     username: 'name'
 *     password: 'pass'
 *   }
 *   origin: "https://foo.google.com"
 *   fileServer: null
 *   strategy: "http"
 *   domainName: "google.com"
 *   props: {
 *     port: 443
 *     tld: "com"
 *     domain: "google"
 *     protocol: "https"
 *   }
 * }
 */
class RemoteStates {
    constructor(configure, documentDomainInjection) {
        this.configure = configure;
        this.documentDomainInjection = documentDomainInjection;
        this.remoteStates = new Map();
        this.primaryOriginKey = '';
        this.currentOriginKey = '';
    }
    get(url) {
        debug('get (origin key)', this.documentDomainInjection.getOrigin(url), this.remoteStates);
        const state = this.remoteStates.get(this.documentDomainInjection.getOrigin(url));
        debug('getting remote state: %o for: %s', state, url);
        return lodash_1.default.cloneDeep(state);
    }
    hasPrimary() {
        const remoteStates = Array.from(this.remoteStates.entries());
        return !!(remoteStates.length && remoteStates[0] && remoteStates[0][1]);
    }
    getPrimary() {
        const state = Array.from(this.remoteStates.entries())[0][1];
        debug('getting primary remote state: %o', state);
        return state;
    }
    isPrimarySuperDomainOrigin(url) {
        return this.primaryOriginKey === this.documentDomainInjection.getOrigin(url);
    }
    reset() {
        debug('resetting remote state');
        const stateArray = Array.from(this.remoteStates.entries());
        // reset the remoteStates and originStack to the primary
        this.remoteStates = new Map(stateArray[0] ? [stateArray[0]] : []);
        this.currentOriginKey = this.primaryOriginKey;
    }
    current() {
        return this.get(this.currentOriginKey);
    }
    _stateFromUrl(url) {
        const remoteOrigin = network_1.uri.origin(url);
        const remoteProps = network_1.cors.parseUrlIntoHostProtocolDomainTldPort(remoteOrigin);
        if ((url === '<root>') || !fullyQualifiedRe.test(url)) {
            return {
                origin: `http://${exports.DEFAULT_DOMAIN_NAME}:${this.ports.server}`,
                strategy: 'file',
                fileServer: lodash_1.default.compact([`http://${exports.DEFAULT_DOMAIN_NAME}`, this.ports.fileServer]).join(':'),
                domainName: exports.DEFAULT_DOMAIN_NAME,
                props: null,
            };
        }
        return {
            origin: remoteOrigin,
            strategy: 'http',
            fileServer: null,
            domainName: network_1.cors.getDomainNameFromParsedHost(remoteProps),
            props: remoteProps,
        };
    }
    set(urlOrState, options = {}, isPrimaryOrigin = true) {
        const state = lodash_1.default.isString(urlOrState) ?
            {
                ...this._stateFromUrl(urlOrState),
                auth: options.auth,
            } :
            urlOrState;
        this.currentOriginKey = this.documentDomainInjection.getOrigin(state.origin);
        if (isPrimaryOrigin) {
            // convert map to array
            const stateArray = Array.from(this.remoteStates.entries());
            // set the primary remote state and convert back to map
            stateArray[0] = [this.currentOriginKey, state];
            this.remoteStates = new Map(stateArray);
            this.primaryOriginKey = this.currentOriginKey;
        }
        else {
            this.remoteStates.set(this.currentOriginKey, state);
        }
        debug('setting remote state %o for %s', state, this.currentOriginKey);
        return this.get(this.currentOriginKey);
    }
    get ports() {
        if (!this.serverPorts) {
            this.serverPorts = this.configure();
        }
        return this.serverPorts;
    }
}
exports.RemoteStates = RemoteStates;
