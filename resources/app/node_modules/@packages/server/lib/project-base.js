"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectBase = void 0;
const tslib_1 = require("tslib");
const check_more_types_1 = tslib_1.__importDefault(require("check-more-types"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const events_1 = tslib_1.__importDefault(require("events"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
const root_1 = tslib_1.__importDefault(require("../../root"));
const automation_1 = require("./automation");
const browsers_1 = tslib_1.__importDefault(require("./browsers"));
const config = tslib_1.__importStar(require("./config"));
const errors = tslib_1.__importStar(require("./errors"));
const preprocessor_1 = tslib_1.__importDefault(require("./plugins/preprocessor"));
const run_events_1 = tslib_1.__importDefault(require("./plugins/run_events"));
const reporter_1 = tslib_1.__importDefault(require("./reporter"));
const savedState = tslib_1.__importStar(require("./saved_state"));
const socket_ct_1 = require("./socket-ct");
const socket_e2e_1 = require("./socket-e2e");
const class_helpers_1 = require("./util/class-helpers");
const system_1 = tslib_1.__importDefault(require("./util/system"));
const types_1 = require("../../types");
const data_context_1 = require("../../data-context");
const crypto_1 = require("crypto");
const server_base_1 = require("./server-base");
const uuid_1 = require("uuid");
const StudioLifecycleManager_1 = require("./cloud/studio/StudioLifecycleManager");
const report_studio_error_1 = require("./cloud/api/studio/report_studio_error");
const cloud_request_1 = require("./cloud/api/cloud_request");
const is_retryable_error_1 = require("./cloud/network/is_retryable_error");
const async_retry_1 = require("./util/async_retry");
const get_cloud_metadata_1 = require("./cloud/get_cloud_metadata");
const TelemetryManager_1 = require("./cloud/studio/telemetry/TelemetryManager");
const initialization_1 = require("./cloud/studio/telemetry/constants/initialization");
const TelemetryReporter_1 = require("./cloud/studio/telemetry/TelemetryReporter");
const localCwd = process.cwd();
const debug = (0, debug_1.default)('cypress:server:project');
const debugVerbose = (0, debug_1.default)('cypress-verbose:server:project');
class ProjectBase extends events_1.default {
    constructor({ projectRoot, testingType, options = {}, }) {
        super();
        this._recordTests = null;
        this._isServerOpen = false;
        this.isOpen = false;
        this.ensureProp = class_helpers_1.ensureProp;
        this.shouldCorrelatePreRequests = () => {
            return !!this.browser;
        };
        if (!projectRoot) {
            throw new Error('Instantiating lib/project requires a projectRoot!');
        }
        if (!check_more_types_1.default.unemptyString(projectRoot)) {
            throw new Error(`Expected project root path, not ${projectRoot}`);
        }
        this.testingType = testingType;
        this.projectRoot = path_1.default.resolve(projectRoot);
        this.spec = null;
        this.browser = null;
        this.id = (0, crypto_1.createHmac)('sha256', 'secret-key').update(projectRoot).digest('hex');
        this.ctx = (0, data_context_1.getCtx)();
        debug('Project created %o', {
            testingType: this.testingType,
            projectRoot: this.projectRoot,
        });
        this.options = {
            report: false,
            onFocusTests() { },
            onError(error) {
                errors.log(error);
            },
            onWarning: this.ctx.onWarning,
            ...options,
        };
    }
    setOnTestsReceived(fn) {
        this._recordTests = fn;
    }
    get server() {
        return this.ensureProp(this._server, 'open');
    }
    get automation() {
        return this.ensureProp(this._automation, 'open');
    }
    get cfg() {
        return this._cfg;
    }
    get state() {
        return this.cfg.state;
    }
    get remoteStates() {
        var _a;
        return (_a = this._server) === null || _a === void 0 ? void 0 : _a.remoteStates;
    }
    async open() {
        var _a;
        debug('opening project instance %s', this.projectRoot);
        debug('project open options %o', this.options);
        const cfg = this.getConfig();
        process.chdir(this.projectRoot);
        this._server = new server_base_1.ServerBase(cfg);
        if (!cfg.isTextTerminal) {
            const studioLifecycleManager = new StudioLifecycleManager_1.StudioLifecycleManager();
            studioLifecycleManager.initializeStudioManager({
                projectId: cfg.projectId,
                cloudDataSource: this.ctx.cloud,
                cfg,
                debugData: this.configDebugData,
                ctx: this.ctx,
            });
        }
        const [port, warning] = await this._server.open(cfg, {
            getCurrentBrowser: () => this.browser,
            getSpec: () => this.spec,
            onError: this.options.onError,
            onWarning: this.options.onWarning,
            shouldCorrelatePreRequests: this.shouldCorrelatePreRequests,
            testingType: this.testingType,
            SocketCtor: this.testingType === 'e2e' ? socket_e2e_1.SocketE2E : socket_ct_1.SocketCt,
        });
        this.ctx.actions.servers.setAppServerPort(port);
        this._isServerOpen = true;
        // if we didnt have a cfg.port
        // then get the port once we
        // open the server
        if (!cfg.port) {
            cfg.port = port;
            // and set all the urls again
            lodash_1.default.extend(cfg, config.setUrls(cfg));
        }
        cfg.proxyServer = cfg.proxyUrl;
        // store the cfg from
        // opening the server
        this._cfg = cfg;
        debug('project config: %o', lodash_1.default.omit(cfg, 'resolved'));
        if (warning) {
            this.options.onWarning(warning);
        }
        // save the last time they opened the project
        // along with the first time they opened it
        const now = Date.now();
        const stateToSave = {
            lastOpened: now,
            lastProjectId: (_a = cfg.projectId) !== null && _a !== void 0 ? _a : null,
        };
        if (!cfg.state || !cfg.state.firstOpened) {
            stateToSave.firstOpened = now;
        }
        this.startWebsockets({
            onReloadBrowser: this.options.onReloadBrowser,
            onFocusTests: this.options.onFocusTests,
            onSpecChanged: this.options.onSpecChanged,
        }, {
            socketIoCookie: cfg.socketIoCookie,
            namespace: cfg.namespace,
            screenshotsFolder: cfg.screenshotsFolder,
            report: cfg.report,
            reporter: cfg.reporter,
            reporterOptions: cfg.reporterOptions,
            projectRoot: this.projectRoot,
        });
        await this.saveState(stateToSave);
        if (cfg.isTextTerminal) {
            return;
        }
        if (!cfg.experimentalInteractiveRunEvents) {
            return;
        }
        const sys = await system_1.default.info();
        const beforeRunDetails = {
            config: cfg,
            cypressVersion: root_1.default.version,
            system: lodash_1.default.pick(sys, 'osName', 'osVersion'),
        };
        this.isOpen = true;
        return run_events_1.default.execute('before:run', beforeRunDetails);
    }
    reset() {
        var _a;
        debug('resetting project instance %s', this.projectRoot);
        // if we're in studio mode, we need to close the protocol manager
        // to ensure the config is initialized properly on browser relaunch
        if (this.ctx.coreData.studioLifecycleManager) {
            (_a = this.protocolManager) === null || _a === void 0 ? void 0 : _a.close();
            this.protocolManager = undefined;
        }
        this.spec = null;
        this.browser = null;
        if (this._automation) {
            this._automation.reset();
        }
        if (this._server) {
            return this._server.reset();
        }
        return;
    }
    __reset() {
        preprocessor_1.default.close();
        process.chdir(localCwd);
    }
    async close() {
        var _a;
        debug('closing project instance %s', this.projectRoot);
        this.spec = null;
        this.browser = null;
        if (!this._isServerOpen) {
            return;
        }
        this.__reset();
        this.ctx.actions.servers.setAppServerPort(undefined);
        this.ctx.actions.servers.setAppSocketServer(undefined);
        await Promise.all([
            (_a = this.server) === null || _a === void 0 ? void 0 : _a.close(),
        ]);
        this._isServerOpen = false;
        this.isOpen = false;
        const config = this.getConfig();
        if (config.isTextTerminal || !config.experimentalInteractiveRunEvents)
            return;
        return run_events_1.default.execute('after:run');
    }
    initializeReporter({ report, reporter, projectRoot, reporterOptions, }) {
        if (!report) {
            return;
        }
        try {
            reporter_1.default.loadReporter(reporter, projectRoot);
        }
        catch (error) {
            const paths = reporter_1.default.getSearchPathsForReporter(reporter, projectRoot);
            errors.throwErr('INVALID_REPORTER_NAME', {
                paths,
                error,
                name: reporter,
            });
        }
        return reporter_1.default.create(reporter, reporterOptions, projectRoot);
    }
    startWebsockets(options, { socketIoCookie, namespace, screenshotsFolder, report, reporter, reporterOptions, projectRoot }) {
        // if we've passed down reporter
        // then record these via mocha reporter
        const reporterInstance = this.initializeReporter({
            report,
            reporter,
            reporterOptions,
            projectRoot,
        });
        const onBrowserPreRequest = async (browserPreRequest) => {
            await this.server.addBrowserPreRequest(browserPreRequest);
        };
        const onRequestEvent = (eventName, data) => {
            this.server.emitRequestEvent(eventName, data);
            return Promise.resolve();
        };
        const onRemoveBrowserPreRequest = (requestId) => {
            this.server.removeBrowserPreRequest(requestId);
        };
        const onDownloadLinkClicked = (downloadUrl) => {
            this.server.addPendingUrlWithoutPreRequest(downloadUrl);
        };
        const onServiceWorkerRegistrationUpdated = (data) => {
            this.server.updateServiceWorkerRegistrations(data);
        };
        const onServiceWorkerVersionUpdated = (data) => {
            this.server.updateServiceWorkerVersions(data);
        };
        const onServiceWorkerClientSideRegistrationUpdated = (data) => {
            this.server.updateServiceWorkerClientSideRegistrations(data);
        };
        const onServiceWorkerClientEvent = (event) => {
            this.server.handleServiceWorkerClientEvent(event);
        };
        this._automation = new automation_1.Automation({
            cyNamespace: namespace,
            cookieNamespace: socketIoCookie,
            screenshotsFolder,
            onBrowserPreRequest,
            onRequestEvent,
            onRemoveBrowserPreRequest,
            onDownloadLinkClicked,
            onServiceWorkerRegistrationUpdated,
            onServiceWorkerVersionUpdated,
            onServiceWorkerClientSideRegistrationUpdated,
            onServiceWorkerClientEvent,
        });
        const ios = this.server.startWebsockets(this.automation, this.cfg, {
            onReloadBrowser: options.onReloadBrowser,
            onFocusTests: options.onFocusTests,
            onSpecChanged: options.onSpecChanged,
            onSavedStateChanged: (state) => this.saveState(state),
            closeExtraTargets: this.closeExtraTargets,
            onStudioInit: async () => {
                var _a, _b, _c, _d;
                TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.INITIALIZATION_START);
                const endTelemetry = ({ status, canAccessStudioAI }) => {
                    TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.INITIALIZATION_END);
                    TelemetryReporter_1.TelemetryReporter.getInstance().reportTelemetry(initialization_1.INITIALIZATION_TELEMETRY_GROUP_NAMES.INITIALIZE_STUDIO, {
                        status,
                        canAccessStudioAI,
                    });
                };
                const cloudStudioSessionId = (0, uuid_1.v4)();
                try {
                    const isStudioReady = (_a = this.ctx.coreData.studioLifecycleManager) === null || _a === void 0 ? void 0 : _a.isStudioReady();
                    if (!isStudioReady) {
                        debug('User entered studio mode before cloud studio was initialized');
                        const { cloudUrl, cloudHeaders } = await (0, get_cloud_metadata_1.getCloudMetadata)(this.ctx.cloud);
                        (0, report_studio_error_1.reportStudioError)({
                            cloudApi: {
                                cloudUrl,
                                cloudHeaders,
                                CloudRequest: cloud_request_1.CloudRequest,
                                isRetryableError: is_retryable_error_1.isRetryableError,
                                asyncRetry: async_retry_1.asyncRetry,
                            },
                            studioHash: this.id,
                            projectSlug: this.cfg.projectId,
                            error: new Error('User entered studio before cloud studio was initialized'),
                            studioMethod: 'onStudioInit',
                            studioMethodArgs: [],
                        });
                        endTelemetry({ status: 'studio-not-ready', canAccessStudioAI: false });
                        return { canAccessStudioAI: false, cloudStudioSessionId };
                    }
                    const studio = await ((_b = this.ctx.coreData.studioLifecycleManager) === null || _b === void 0 ? void 0 : _b.getStudio());
                    // only capture studio started event if the user is accessing legacy studio
                    if (!((_c = this.ctx.coreData.studioLifecycleManager) === null || _c === void 0 ? void 0 : _c.cloudStudioRequested)) {
                        try {
                            studio === null || studio === void 0 ? void 0 : studio.captureStudioEvent({
                                type: types_1.StudioMetricsTypes.STUDIO_STARTED,
                                machineId: await this.ctx.coreData.machineId,
                                projectId: this.cfg.projectId,
                                browser: this.browser ? {
                                    name: this.browser.name,
                                    family: this.browser.family,
                                    channel: this.browser.channel,
                                    version: this.browser.version,
                                } : undefined,
                                cypressVersion: root_1.default.version,
                            });
                        }
                        catch (error) {
                            debug('Error capturing studio event:', error);
                        }
                    }
                    if (this.spec && (studio === null || studio === void 0 ? void 0 : studio.protocolManager)) {
                        TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.CAN_ACCESS_STUDIO_AI_START);
                        const canAccessStudioAI = (_d = await (studio === null || studio === void 0 ? void 0 : studio.canAccessStudioAI(this.browser))) !== null && _d !== void 0 ? _d : false;
                        TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.CAN_ACCESS_STUDIO_AI_END);
                        if (!canAccessStudioAI) {
                            endTelemetry({ status: 'success', canAccessStudioAI });
                            return { canAccessStudioAI, cloudStudioSessionId };
                        }
                        this.protocolManager = studio.protocolManager;
                        this.protocolManager.setupProtocol();
                        this.protocolManager.beforeSpec({
                            ...this.spec,
                            instanceId: (0, uuid_1.v4)(),
                        });
                        TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.CONNECT_PROTOCOL_TO_BROWSER_START);
                        await browsers_1.default.connectProtocolToBrowser({ browser: this.browser, foundBrowsers: this.options.browsers, protocolManager: studio.protocolManager });
                        TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.CONNECT_PROTOCOL_TO_BROWSER_END);
                        if (!studio.protocolManager.dbPath) {
                            debug('Protocol database path is not set after initializing protocol manager');
                            endTelemetry({ status: 'protocol-db-path-not-set', canAccessStudioAI: false });
                            return { canAccessStudioAI: false, cloudStudioSessionId };
                        }
                        TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.INITIALIZE_STUDIO_AI_START);
                        await studio.initializeStudioAI({
                            protocolDbPath: studio.protocolManager.dbPath,
                        });
                        TelemetryManager_1.telemetryManager.mark(initialization_1.INITIALIZATION_MARK_NAMES.INITIALIZE_STUDIO_AI_END);
                        endTelemetry({ status: 'success', canAccessStudioAI: true });
                        return { canAccessStudioAI: true, cloudStudioSessionId };
                    }
                    this.protocolManager = undefined;
                    endTelemetry({ status: 'success', canAccessStudioAI: false });
                    return { canAccessStudioAI: false, cloudStudioSessionId };
                }
                catch (error) {
                    endTelemetry({ status: 'exception', canAccessStudioAI: false });
                    return { canAccessStudioAI: false, cloudStudioSessionId };
                }
            },
            onStudioDestroy: async () => {
                var _a, _b, _c;
                const isStudioReady = await ((_a = this.ctx.coreData.studioLifecycleManager) === null || _a === void 0 ? void 0 : _a.isStudioReady());
                if (!isStudioReady) {
                    debug('Studio is not ready - skipping destroy');
                    return;
                }
                const studio = await ((_b = this.ctx.coreData.studioLifecycleManager) === null || _b === void 0 ? void 0 : _b.getStudio());
                await (studio === null || studio === void 0 ? void 0 : studio.destroy());
                if (this.protocolManager) {
                    await browsers_1.default.closeProtocolConnection({ browser: this.browser, foundBrowsers: this.options.browsers });
                    (_c = this.protocolManager) === null || _c === void 0 ? void 0 : _c.close();
                    this.protocolManager = undefined;
                }
            },
            onCaptureVideoFrames: (data) => {
                // TODO: move this to browser automation middleware
                this.emit('capture:video:frames', data);
            },
            onConnect: (id) => {
                debug('socket:connected');
                this.emit('socket:connected', id);
            },
            onTestsReceivedAndMaybeRecord: async (runnables, cb) => {
                var _a, _b;
                debug('received runnables %o', runnables);
                if (reporterInstance) {
                    reporterInstance.setRunnables(runnables, this.getConfig());
                }
                if (this._recordTests) {
                    (_a = this._protocolManager) === null || _a === void 0 ? void 0 : _a.addRunnables(runnables);
                    await ((_b = this._recordTests) === null || _b === void 0 ? void 0 : _b.call(this, runnables, cb));
                    this._recordTests = null;
                    return;
                }
                cb();
            },
            onMocha: async (event, runnable) => {
                // bail if we dont have a
                // reporter instance
                if (!reporterInstance) {
                    return;
                }
                reporterInstance.emit(event, runnable);
                if (event === 'test:before:run') {
                    debugVerbose('browserPreRequests prior to running %s: %O', runnable.title, this.server.getBrowserPreRequests());
                    this.emit('test:before:run', {
                        runnable,
                        previousResults: (reporterInstance === null || reporterInstance === void 0 ? void 0 : reporterInstance.results()) || {},
                    });
                }
                else if (event === 'end') {
                    debugVerbose('browserPreRequests at the end: %O', this.server.getBrowserPreRequests());
                    const [stats = {}] = await Promise.all([
                        (reporterInstance != null ? reporterInstance.end() : undefined),
                        this.server.end(),
                    ]);
                    this.emit('end', stats);
                }
                return;
            },
        });
        this.ctx.actions.servers.setAppSocketServer(ios);
    }
    async resetBrowserTabsForNextSpec(shouldKeepTabOpen) {
        return this.server.socket.resetBrowserTabsForNextSpec(shouldKeepTabOpen);
    }
    async resetBrowserState() {
        return this.server.socket.resetBrowserState();
    }
    closeExtraTargets() {
        return browsers_1.default.closeExtraTargets();
    }
    isRunnerSocketConnected() {
        return this.server.socket.isRunnerSocketConnected();
    }
    async sendFocusBrowserMessage() {
        if (this.browser.family === 'firefox') {
            await browsers_1.default.setFocus();
        }
        else {
            await this.server.sendFocusBrowserMessage();
        }
    }
    setCurrentSpecAndBrowser(spec, browser) {
        var _a;
        this.spec = spec;
        this.browser = browser;
        if (this.browser.family !== 'chromium') {
            // If we're not in chromium, our strategy for correlating service worker prerequests doesn't work in non-chromium browsers (https://github.com/cypress-io/cypress/issues/28079)
            // in order to not hang for 2 seconds, we override the prerequest timeout to be 500 ms (which is what it has been historically).
            (_a = this._server) === null || _a === void 0 ? void 0 : _a.setPreRequestTimeout(500);
        }
    }
    get protocolManager() {
        return this._protocolManager;
    }
    set protocolManager(protocolManager) {
        var _a;
        this._protocolManager = protocolManager;
        (_a = this._server) === null || _a === void 0 ? void 0 : _a.setProtocolManager(protocolManager);
    }
    getAutomation() {
        return this.automation;
    }
    async initializeConfig() {
        this.ctx.lifecycleManager.setAndLoadCurrentTestingType(this.testingType);
        let theCfg = {
            ...(await this.ctx.lifecycleManager.getFullInitialConfig()),
            testingType: this.testingType,
        }; // ?? types are definitely wrong here I think
        if (theCfg.isTextTerminal) {
            this._cfg = theCfg;
            return this._cfg;
        }
        const cfgWithSaved = await this._setSavedState(theCfg);
        this._cfg = cfgWithSaved;
        return this._cfg;
    }
    // returns project config (user settings + defaults + cypress.config.{js,ts,mjs,cjs})
    // with additional object "state" which are transient things like
    // window width and height, DevTools open or not, etc.
    getConfig() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (!this._cfg) {
            throw Error('Must call #initializeConfig before accessing config.');
        }
        debug('project has config %o', this._cfg);
        const isDefaultProtocolEnabled = (_b = (_a = this._protocolManager) === null || _a === void 0 ? void 0 : _a.isProtocolEnabled) !== null && _b !== void 0 ? _b : false;
        const hideRunnerUi = (((_d = (_c = this.options) === null || _c === void 0 ? void 0 : _c.args) === null || _d === void 0 ? void 0 : _d.runnerUi) === false ||
            (isDefaultProtocolEnabled && this._cfg.isTextTerminal && !((_f = (_e = this.options) === null || _e === void 0 ? void 0 : _e.args) === null || _f === void 0 ? void 0 : _f.runnerUi)));
        // hide the command log if explicitly requested or if we are hiding the runner
        const hideCommandLog = ((_g = this._cfg.env) === null || _g === void 0 ? void 0 : _g.NO_COMMAND_LOG) === 1 || hideRunnerUi;
        return {
            ...this._cfg,
            remote: (_j = (_h = this.remoteStates) === null || _h === void 0 ? void 0 : _h.current()) !== null && _j !== void 0 ? _j : {},
            browser: this.browser,
            testingType: (_k = this.ctx.coreData.currentTestingType) !== null && _k !== void 0 ? _k : 'e2e',
            specs: [],
            isDefaultProtocolEnabled,
            hideCommandLog,
            hideRunnerUi,
        };
    }
    // Saved state
    // forces saving of project's state by first merging with argument
    async saveState(stateChanges = {}) {
        if (!this.cfg) {
            throw new Error('Missing project config');
        }
        if (!this.projectRoot) {
            throw new Error('Missing project root');
        }
        let state = await savedState.create(this.projectRoot, this.cfg.isTextTerminal);
        state.set(stateChanges);
        this.cfg.state = await state.get();
        return this.cfg.state;
    }
    async _setSavedState(cfg) {
        debug('get saved state');
        const state = await savedState.create(this.projectRoot, cfg.isTextTerminal);
        cfg.state = await state.get();
        return cfg;
    }
    // These methods are not related to start server/sockets/runners
    async getProjectId() {
        return (0, data_context_1.getCtx)().lifecycleManager.getProjectId();
    }
    get configDebugData() {
        return this.ctx.lifecycleManager.configDebugData;
    }
    // For testing
    // Do not use this method outside of testing
    // pass all your options when you create a new instance!
    __setOptions(options) {
        this.options = options;
    }
    __setConfig(cfg) {
        this._cfg = cfg;
    }
}
exports.ProjectBase = ProjectBase;
