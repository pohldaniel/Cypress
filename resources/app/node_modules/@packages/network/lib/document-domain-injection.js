"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OriginBehavior = exports.DocumentDomainBehavior = exports.DocumentDomainInjection = void 0;
const tslib_1 = require("tslib");
/*
utility to help determine if document.domain should be injected, or related logic invoked
this class isn't necessarily network related, but it is used from a wide ranging number
of packages. It should probably be its own ./package. for now, it's sort of a facade for all
of this logic, which should help inform a subsequent refactor strategy.

  behaviors controlled:
  - how to key origins of RemoteStates (server/lib/remote_states)
  - whether to inject document.domain in the server render of top (server/lib/controllers/files)
  - whether to inject document.domain in proxied files (proxy/lib/http/response-middleware)
  - how to verify stack traces of privileged commands in chrome
*/
const debug_1 = tslib_1.__importDefault(require("debug"));
const lodash_1 = require("lodash");
const cors_1 = require("./cors");
const debug = (0, debug_1.default)('cypress:network:document-domain-injection');
class DocumentDomainInjection {
    static InjectionBehavior(config) {
        debug('Determining injection behavior for config values: %o', {
            injectDocumentDomain: config.injectDocumentDomain,
            testingType: config.testingType,
        });
        if (config.injectDocumentDomain && config.testingType !== 'component') {
            debug('Returning document domain injection behavior');
            return new DocumentDomainBehavior();
        }
        debug('Returning origin behavior - no document domain injection');
        return new OriginBehavior();
    }
}
exports.DocumentDomainInjection = DocumentDomainInjection;
class DocumentDomainBehavior {
    getOrigin(url) {
        return (0, cors_1.getSuperDomainOrigin)(url);
    }
    getHostname(url) {
        return (0, cors_1.getSuperDomain)(url);
    }
    urlsMatch(frameUrl, topUrl) {
        const frameProps = (0, lodash_1.isString)(frameUrl) ? (0, cors_1.parseUrlIntoHostProtocolDomainTldPort)(frameUrl) : frameUrl;
        const topProps = (0, lodash_1.isString)(topUrl) ? (0, cors_1.parseUrlIntoHostProtocolDomainTldPort)(topUrl) : topUrl;
        const { subdomain: frameSubdomain, ...parsedFrameUrl } = frameProps;
        const { subdomain: topSubdomain, ...parsedTopUrl } = topProps;
        return (0, lodash_1.isEqual)(parsedFrameUrl, parsedTopUrl);
    }
    shouldInjectDocumentDomain(url) {
        debug('document-domain behavior: should inject document domain -> true');
        return !!url;
    }
}
exports.DocumentDomainBehavior = DocumentDomainBehavior;
class OriginBehavior {
    getOrigin(url) {
        return new URL(url).origin;
    }
    getHostname(url) {
        return new URL(url).hostname;
    }
    urlsMatch(frameUrl, topUrl) {
        const frameProps = (0, lodash_1.isString)(frameUrl) ? (0, cors_1.parseUrlIntoHostProtocolDomainTldPort)(frameUrl) : frameUrl;
        const topProps = (0, lodash_1.isString)(topUrl) ? (0, cors_1.parseUrlIntoHostProtocolDomainTldPort)(topUrl) : topUrl;
        return (0, lodash_1.isEqual)(frameProps, topProps);
    }
    shouldInjectDocumentDomain(url) {
        debug('origin-behavior: should inject document domain -> false');
        return false;
    }
}
exports.OriginBehavior = OriginBehavior;
